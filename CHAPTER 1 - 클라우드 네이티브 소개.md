
## 클라우드 네이티브 애플리케이션이란?
</br>
: 클라우드에서 실행되면서 변화에 탄력적으로 대응하고 고도로 분산되어 있는 시스템 </br>
시스템은 여러 개의 서비스로 구성- 이 서비스들은 네트워크를 통해 서로 통신 </br>
이 시스템은 끊임없이 변하는 동적 환경에 배포 </br>
</br>

클라우드 네이티브 - 클라우드 기술의 활용을 목표로 애플리케이션 개발 위한 접근방식 
</br>
</br>

## 1.1 클라우드 네이티브란 무엇인가?
폴 프리맨틀(클라우드 업계 베테랑) : 마이크로소프트, 도커, 데브옵스 이런 개념 존재 하지 않던 시기에 애플리케이션과 미들웨어가 클라우드 환경에서 잘 작동하기 위해 필요한 것</br>
: 클라우드 네이티브가 되기 위해 무엇이 필요한지 토의함</br>
</br>
1. 클라우드를 위해 특별히 설계되어야 함 </br>
2. 환경과 모델의 장점을 활용한 특성이 있어야 함</br>
</br>

## 1.1.1 클라우드 네이티브에서의 세 가지 P
클라우드를 위해 특별히 설계된다는 건?</br>
클라우드의 세 가지 P : 1. 플랫폼 2. 속성 3. 실행</br>
</br>
1. 플랫폼 : 클라우드 같은 동적 분산 환경을 기반으로 하는 플랫폼에서 실행됨</br>
2. 속성 : 확장 가능, 느슨 결합, 복원력 뛰어남, 관리 용이, 관찰 가능 </br>
3. 실행 : 견고한 자동화 통해 예측가능한 방식으로 시스템 변경 </br>
</br>

## 클라우드와 클라우드 컴퓨팅 모델 
실행되는 환경인 클라우드에 대해 설명할 것 </br>

클라우드는 컴퓨팅 자원을 소비자에게 제공하는 IT 인프라</br>
클라우드를 사용하는 기업 : 네트워크를 사용한 API를 통해 필요에 따라 리소스 제공/ 확장 가능한 온디맨드 서비스 통해 자원얻을 수 있음 </br>

=> 탄력성이 주요 특징 </br>

</br>
클라우드 서비스 제공위한 배포모델</br>

### 사설 클라우드 
: 한 단체나 조직에서만 사용하도록 제공하는 클라우드 인프라 </br>

### 공공 클라우드 
: 일반 사용자들에게 공공으로 제공되는 클라우드 인프라 </br>
- aws, Azure 등등

### 하이브리드 클라우드 
: 앞선 것들 중 클라우드 인프라 구성 몇개를 하나로 묶어 마치 하나의 단일 환경인 것처럼 서비스 제공</br>
</br>

클라우드 서비스 모델은 소비자에게 제공되는 기능으로 다섯가지로 나뉨</br>
- Iaas
- Caas
- Paas
- Faas
- Saas
Iaas -> Saas
이렇게 갈 수록 사용자의 책임이 줄어든다</br>
반면 플랫폼의 책임은 늘어난다. </br>
</br>

## 1.2.1 서비스형 인프라스트럭처 IaaS
IaaS모델에서 사용자는 서버, 스토리지, 및 네트워크와 같은 자원을 직접 제어 및 제공가능</br>
- AWS:EC2, Azure:virtual Machine
</br>

## 1.2.2 서비스형 컨테이너 CaaS
CaaS모델에서 사용자는 가상화를 위한 기본 리소스를 제어할 수 없고 대신 컨테이너를 만들고 관리함</br>
클라우드 공급자는 기본 리소스를 제공함: ex-새로운 가상머신을 만들고 인터넷 통한 액세스위해 네트워크 구성해줌</br>
컨테이너 플랫폼 구축위한 도구 : 도커, 쿠버네티스</br>
- Amazon Elastic Kubernetes Service EKS
</br>

## 1.2.3 서비스형 플랫폼 PaaS
클라우드 공급자가 인프라, 도구, API를 제공하고 개발자는 이를 사용해 애플리케이션을 빌드하고 배포함</br>
- ex: 개발자가 빌드 후 JAR 파일로 패키징 후, PaaS 모델로 실행되고 있는 플랫폼에 배포할 수 있음 </br>


## 1.2.4 서비스형 함수 FaaS
FaaS 모델의 서버리스 컴퓨팅을 사용하면 사용자는 함수의 형태로 비즈니스 로직을 구현하는 데만 집중할 수 있음</br>
플랫폼은 서버 및 나머지 인프라 제공</br>
서버리스 애플리케이션은?</br>
HTTP 요청이나 메시지 같은 이벤트 발생시 실행하게끔 할수 있음</br>
- ex: 어떤 데이터가 메시지 큐에 들어올 때마다 특정 알고리즘에 따라 결과를 계산하는 함수도 작성가능
- Amazon aws Lambda

## 1.2.5 서비스형 소프트웨어 SaaS
- 가장 추상화된 서비스
- 소비자는 사용자로서 애플리케이션에 액세스
- 클라우드 공급자는 소프트웨어 및 인프라 스택 전체 관리
- 많은 회사가 애플리케이션 만들고 CaaS 또는 PaaS 모델을 통해 실행 후 최종 고객에게 SaaS 형태로 판매함
- GitHub

</br>

## 클라우드 네이티브 애플리케이션의 특성
클라우드는 준비됨, 그 특성 활용 위해 애플리케이션을 어떻게 설계해야할지 보자</br>
- 확장성 : 워크로드의 증가 또는 감소를 동적지원
- 느슨한 결합 : 각각의 구성 요소들은 서로에 대해 최소한의 지식만 갖음
- 회복성 : 문제 직면 시 서비스 수준 유지
- 유지 보수성 : 외부에서의 제어 수준 : 갱신, 설정, 배포
- 관측 가능성 : 내부 상태에 대해 외부로부터 추정된 지식 

## 1.3.1 확장성 
클라우드 네이티브 애플리케이션은 확장 가능함</br>
: 추가 리소스를 제공해 증가하는 워크로드를 지원함 </br>
- 추가 리소스 특성에 따라 수직적 확장/ 수평적 확장
- 수직적 확장(위/아래 확장) : 하드웨어 리소스 추가(무한정 추가 불가,제한적 방식): 애플리케이션 설계시 명시 필요 없음
- 수평적 확장(확대/축소 확장) : 컴퓨팅 노드/ 컨테이너 추가( 제한없음): 애플리케이션 설계시 확장 가능해야함

전통적인 시스템 : 워크로드 증가 시 수직적 확장 채택(일반적)</br>
클라우드 : 수평적 확장 선호</br>
- 이는 클라우드 컴퓨팅 모델이 제공하는 추상화 수준 덕분에 가능</br>
</br>
클라우드는 탄력적임(리소스를 필요에 따라 늘리거나 줄이기 가능), 확장성은 탄력성을 갖추기 위한 전제 조건</br>
</br>


## 1.3.2 느슨한 결합
goal : 한 컴포넌트가 바뀐다고 해서 다른 부분까지 변경할 필요가 없음</br>
- 시스템을 모듈로 분해(모듈화)
- 의존성 최소화(느슨한 결합)
- 함께 변화하는 코드 캡슐화(높은 응집력)
=> 좋은 설계 방법</br>

파르나스의 모듈화 세가지 이점</br>
- 관리: 각 모듈의 팀들은 서로간의 조정, 의사소통에 많은 시간 할애x
- 제품 유연성 : 독립적으로 진화, 전체 시스템은 유연
- 이해력 : 전체를 이해할 필요 없고 하나의 모듈만 이해하고 작업가능


</br>
-> 마이크로서비스와 관련된 이점 </br>
분산된 모놀리스 : 밀접 결합된 시스템을 MSA로 변경하면 단단 결합된 MSA가 됨(이런것들이 존재함을 암시함-부적절)</br>
모듈식 모놀리스 : </br>

## 1.3.3 복원력
복원력 : 결함이나 환경변화 시에도 허용가능한 수준의 서비스 제공할 수 있도록 하는 기능</br>

클라우드 네이티브 시스템 </br>
구축시 목표 : </br>
장애 발생 시 언제나 사용가능하도록 보장하는 것 (가용성) </br>

우리의 마음가짐: </br>
동적환경에서 실행되는 특성상 결함을 사전에 막을 수 없음/ 변화는 예외적 상황 아닌 일어날 법칙 으로 생각</br>

세가지 필수 개념 :</br>
- 결함: 잘못된 내부 상태를 생성하는 원인 제공 장소 (ex 메서드호출, 널 아닌 반환값 넘겨야 함에도 널 값 반환하는 case)
- 오류: 예상 작동과 실제 작동 간의 불일치(ex 위 언급 결함으로 NullpointerException 발생 case)
- 실패: 결함 촉발 오류 발생 실패, 시스템 응답x , (ex nullException 적절하게 처리 x 실패 유발 시스템은 모든 요청에 500코드응답)

이에 애플리케이션은 내결함성(fault tolerant)을 갖게 설계필수</br>
복원력에서 필수적인 부분:</br>
- 실패 발생 시 다른 부분에 영향x
- 실패 발생 부분은 해결까지 격리 상태 유지

## 1.3.4 관측 가능성
외부 출력에서 내부 상태를 얼마나 잘 추론할 수 있는지 측정한 것</br>
외부 출력: 측정값, 로그, 트레이스(trace)와 같은 데이터</br>

관측 가능성의 네 가지 요소: </br>
- 모니터링: 애플리케이션의 전반적인 상태 정보 얻고 특정 양상 측정(ex Spring Boot Actuator:모니터링 기능, prometheus)
- 경고/시각화: 상태 수집 후 조치 취함, dashBoard 사용해 시각화 후 그래프 표시(ex Grafana 활용법)
- 인프라를 추적하는 분산 시스템: 분산 시스템에서는 모든 서버 내의 작동 뿐만 아니라 서로 다른 서버시스템 사이 데이터 추적 필수(ex OpenTelemetry와 Spring 통합, Grafana Tempo 사용해 트레이스 수집 및 시각화)
- 로그 집계/분석: 시스템 작동에 대한 저 나은 데이터 제공 및 분석(ex Fluent Bit, Loki, Grafana 사용해 로그 수집 및 시각화할 것)

## 1.3.5 관리 용이성
제어이론 : 관측 가능성 ~(대응) 제어 가능성</br>
제어 가능성 : 
- 외부 입력 통해 유한시간 내에 시스템 상태 또는 출력 변경하는 능력(얼마나 쉽고 효율적으로)
=> 이 개념은 관리 용이성으로 이어짐</br>

관리 용이성: </br>
코드를 바꾸지 않고도 애플리케이션의 작동을 수정할 수 있는 능력</br>
클라우드 네이티브 애플리케이션이 코드를 변경하거나 릴리즈를 빌드 않고도 작동을 수정할 수 있도록 설정이 바람직</br>


## 1.4 클라우드 네이티브를 지원하는 문화 및 관행
- 자동화: 재생 가능하고 효율적이며 신뢰할 만한 시스템
- 지속적 전달 : 더 낫고 더 빠른 소프트웨어 배포
- 데브옵스 : 서로 다른 역할 사이에서 협업하는 문화
이렇게 세가지 개념에 대해 논의할 것</br>


## 1.4.1 자동화
자동화: </br>
클라우드 네이티브의 핵심(반복적인 수동작업 자동화해 빠르게 배포하자)</br>
장점: </br>
- 프로세스와 작업이 반복 가능
- 시스템이 안정적이고 신뢰 가능
클라우드 자동화의 두가지 중요 범주: 인프라 제공 및 설정 관리</br>
- 코드형 인프라스트럭처infrastructure as code
- 코드형 설정configuration as code

## 마틴 파울러 _ 코드형 인프라스트럭처
: 다른 시스템 다룰 때와 동일한 방식으로 소스 코드를 통해 컴퓨팅 및 네트워크 인프라를 정의하는 접근방식</br>
: cloud 업체는 편리한API 제공함/ 이를 통해 서버, 네트워크,스토리지 생성가능/ 이 작업을 테라폼도구로 자동화 후 형상관리시스템으로 관리/ 동일한 테스트 및 배포 방법 적용 / => 좀 더 안정적이고 예측 가능한 인프라 얻음 </br>
(ex. 우분투 22.04로 새로운 가상머신 하나 생성)

컴퓨팅 리소스를 생성한 후에는?</br>
리소스 관리와 설정을 자동화할 수 있음 => 코드형 설정: 다른 모든 시스템과 동일한 방식으로 리소스에 대한 설정 정의 방식</br>

(ex. 우분투 생성 후 런타임 환경을 JRE 17로 설치, 방화벽 8080포트 여는 등의 작업 자동화 가능)</br>
이렇게 인프라 생성, 설정 관리 작업을 자동화하면, 불안정하고 신뢰성 떨어지는 서버(스노플레이크 서버) 생성 피함</br>
스노플레이크 서버 : </br>
1. 서버 생성 설정관리 등을 수동으로 하면 동일한 서버 나중에 다시 생성 어려움
2. 변경 가능성 있는 취약한 서버되기 쉬움

피닉스 서버 : </br>
1. 모든 작업 자동화
2. 모든 변경 사항 형상관리 시스템 추적
3. 셋업 언제든지 반복 가능 서버 생성
=> 극단으로 가면 **불가변 서버** 얻을 수 있음 </br>

## 1.4.2 지속적 전달
지속적 전달 : </br>
- 프로덕션 환경에 언제든지 배포할 수 있는 방식으로 구축하는 개발의 한 분야
- 이를 통해 짧은 주기로 기능 구현/ 언제든지 안정적 배포 가능 => 큰영향 미치는 변경을 최소한의 노력으로, 자주 예측가능한 방식으로 가하는 것의 **핵심**   
</br>

## 지속적 통합 CI
지속적 통합 : </br>
지속적 전달의 토대가 되는 관행/ 개발자가 변경사항을 기본 브랜치에 적어도 하루에 한 번 커밋</br>
소스 자동 컴파일/테스트/실행 가능한 아티팩트(JAR 파일, 컨테이너 이미지)로 패키징</br>
=> 변경에 대한 빠른 피드백 얻기 위함 / 오류 감지 시 즉시 수정/ 기본 브랜치는 안정적인 토대가 되어야함</br>

## 지속적 전달 CD 
지속적 전달 : </br>
CI를 기반으로 함/ 기본 브랜치가 배포 가능한 상태 유지에 중점/ 아티팩트는 실행 가능상태/소프트웨어는 서비스환경과 유사한 환경에 배포됨</br>
- 이 과정에서 배포 유효성 검증 위해 여러 테스트 거치며 배포 확신 갖게됨
- 기본 브랜치를 항상 배포 가능한 상태에 두는 것이 목표

배포 파이프라인 : </br>
지속적 전달(CD)은 배포 파이프라인을 통해 전체 프로세스의 자동화를 촉진함</br>
: 기본 브랜치 항상 배포 가능하게 유지위한 배포 파이프라인 구축한다고 생각하면 됨</br>

지속적 배포: </br>
지속적 전달을 지속적 배포와 혼동하는 경우 종종</br>
but, 지속적 전달은 배포 가능한지 확인 필요로 함 지속적 배포는 변경된 사항을 프로덕션에 자동 배포함 </br>
</br>
</br>
#2 </br>

## 1.4.3 데브옵스
데브옵스는 클라우드 네이티브로 전환될 때 파악해야할 중요한 개념</br>
> 데브옵스 : 지위나 배경에 관계없이 사람들이 시스템을 구상, 개발, 배포 및 운영하기 위해 함께 협력하는 문화

: 데브옵스는 문화다. 개발 배포 운영 위해 협력하는 문화</br>

- 데브옵스는 노옵스NoOps를 의미하지 않는다.
: 개발자가 운영을 담당한다고 운영자의 역할이 사라진다고 생각하는 실수할 수 있음 하지만 공동작업임</br>

- 데브옵스는 도구가 아니다.
: 도커, 쿠버네티스 같은 툴이 데브옵스 툴이다? -> x </br>
: 데브옵스는 하나의 문화임 툴을 사용한다고 해서 데브옵스 조직이 될 수 없음</br>

- 데브옵스는 자동화가 아니다.
: 자동화가 데브옵스의 필수 부분이긴함, 그래도 = 은 아님 </br>
: 데브옵스는 지속적 전달과 같은 프로세스 중 일부 자동화 가능 </br>
  (아이디어에서 생산까지 함께 작업하는 개발자와 운영자에 관한 것)</br>

- 데브옵스는 역할이 아니다.
: 우리가 데브옵스를 올바르게 생각하면 데브옵스의 역할을 이해하기 어렵다. 그런데! 역할이 아님에도! 데브옵스 엔지니어에 대한 요청 증가중 ~ </br>

- 데브옵스는 팀이 아니다.
: 만약 데브옵스를 잘못 이해한다면 데브옵스 팀으로 운영팀을 대체할 수도ㅋ(아님 새로 추가할 수도) </br>

데브옵스가 개발자와 운영자에 관한 것이라 했음, </br>
클라우드 네이티브로 옮겨갈 때 개발자와 운영자간의 협력이 가장 중요함=> 데브옵스랑 관련 있는 것 </br>
</br>
근데 개발자와 운영자만 책임있는게 아니고 테스터 및 보안전문가들 모두 책임이있고 지속적 전달이라는 목표 달성위해 모두 중요한 존재임</br>


## 1.5 클라우드가 최선의 선택인가?
업계의 큰 실수 중 하나 : 새로운 기술을 모든 사람들이 언급한다는 이유 만으로 그것을 채택함 </br>
근데 말이야. 시스템이 클라우드 네이티브를 통해 해결하려는 문제점 없고, 그런 속성이 필요 없다면 클라우드 네이티브는 최적의 방안 아님 </br>

- 특정 기술, 접근 방식이 문제를 해결할 수 있는 지 파악이 핵심

언제, 왜 클라우드 네이티브 방식을 채택해야 할까?</br>
- 비전에 클라우드 네이티브 주요 목표인 속도, 확장성, 복원력 및 비용이 목표로 포함되어 있음
- 클라우드 기술로 해결하려는 문제점을 가지고 있음
하지만 이런 상황이 아니라면, 클라우드를 사용하지 않는 것이 오히려 조아</br>
ex. 모놀리스가 10년 동안 잘 작동해 왔으면, 클라우드 굳이 ?

> 클라우드 네이티브로 옮겨갈 때 속도, 복원력, 확장성, 및 비용 최적화를 달성하려는 목표 가짐


## 1.5.1 속도 
소프트웨어를 더 신속하게 출시 => 경쟁에서의 우위 </br>
고객들은 버그 수정 및 더 많은 기능을 당.장. 해주길 바람</br>

- 신속/빈번 출시
- 고객에게 더빠른 피드백(피드백 루프 짧아짐)
- 새로운 기능 관련 위험 감소 ( 몇달 거쳐 완벽? ㄴㄴ 바로출시 고객 피드백 받아 기대 부응)
- 작은 릴리스는 변경사항 작아 실패 가능성 작음

전통적인 개발 방식 : 대규모 릴리스, 유연성 부족, 늘어진 출시 사이클 </br>
=> (자동화 된 작업, 지속적 전달과 같은) 클라우드 네이티브 접근방식 통한다면 기업은 출시 시간 단축 가능 </br>


## 1.5.2 복원력 
모든 것은 변하고 실패는 항상 일어나기에, 변화는 예외가 아니라 상수(변하지 않는 수)다.</br>
복원력이 좋다?</br>
- 잘못된 일이 발생하더라도 서비스 계속 제공
- 문제 해결과정이 다운타임 없이 수행

클라우드 기술을 통해 "복원력 높은" 클라우드 네이티브 애플리케이션 사용 가능 => 가용성/복원력 높기 원함?</br>
: 클라우드 네이티브는 GOOD 선택 </br>


## 1.5.3 확장성 
앞으로 일어날 일 예측 => 어려움/ 확장 가능 기능으로는 no 충분 => 상황에 따라 동적으로 확장 할 수 있어야함 </br>
: 부하 up _ 동적/신속/어려움 없이 확장 가능해야 함 / 부하 down _ 인스턴스 줄이기</br>

비즈니스가 고객에게 신속/효율적 적응 필요로 한다면?(유연성 필요)=> </br>
클라우드 네이티브 애플리케이션과 클라우드와 결합해 사용하면 탄력성 확보 가능 </br>


## 1.5.4 비용
클라우드 컴퓨팅 모델은 탄력성과 온디맨드 사용당 지불 정책으로, IT 인프라 비용 최적화에 도움</br>
- 실제 사용한 만큼만 지불하고, 필요 없는 자원은 회수
- 클라우드 네이티브 방식 채택 시 비용 최적화 가능
: 클라우드 네이티브 애플리케이션은 탄력성 활용 위해 확장 가능토록 설계 => 복원력 높아 => 다운타임, 시스템 실패 관련 비용 감소</br>

##1.6 클라우드 네이티브 구성 




