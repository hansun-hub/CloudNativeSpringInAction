
## 클라우드 네이티브 애플리케이션이란?
</br>
: 클라우드에서 실행되면서 변화에 탄력적으로 대응하고 고도로 분산되어 있는 시스템 </br>
시스템은 여러 개의 서비스로 구성- 이 서비스들은 네트워크를 통해 서로 통신 </br>
이 시스템은 끊임없이 변하는 동적 환경에 배포 </br>
</br>

클라우드 네이티브 - 클라우드 기술의 활용을 목표로 애플리케이션 개발 위한 접근방식 
</br>
</br>

## 1.1 클라우드 네이티브란 무엇인가?
폴 프리맨틀(클라우드 업계 베테랑) : 마이크로소프트, 도커, 데브옵스 이런 개념 존재 하지 않던 시기에 애플리케이션과 미들웨어가 클라우드 환경에서 잘 작동하기 위해 필요한 것</br>
: 클라우드 네이티브가 되기 위해 무엇이 필요한지 토의함</br>
</br>
1. 클라우드를 위해 특별히 설계되어야 함 </br>
2. 환경과 모델의 장점을 활용한 특성이 있어야 함</br>
</br>

## 1.1.1 클라우드 네이티브에서의 세 가지 P
클라우드를 위해 특별히 설계된다는 건?</br>
클라우드의 세 가지 P : 1. 플랫폼 2. 속성 3. 실행</br>
</br>
1. 플랫폼 : 클라우드 같은 동적 분산 환경을 기반으로 하는 플랫폼에서 실행됨</br>
2. 속성 : 확장 가능, 느슨 결합, 복원력 뛰어남, 관리 용이, 관찰 가능 </br>
3. 실행 : 견고한 자동화 통해 예측가능한 방식으로 시스템 변경 </br>
</br>

## 클라우드와 클라우드 컴퓨팅 모델 
실행되는 환경인 클라우드에 대해 설명할 것 </br>

클라우드는 컴퓨팅 자원을 소비자에게 제공하는 IT 인프라</br>
클라우드를 사용하는 기업 : 네트워크를 사용한 API를 통해 필요에 따라 리소스 제공/ 확장 가능한 온디맨드 서비스 통해 자원얻을 수 있음 </br>

=> 탄력성이 주요 특징 </br>

</br>
클라우드 서비스 제공위한 배포모델</br>

### 사설 클라우드 
: 한 단체나 조직에서만 사용하도록 제공하는 클라우드 인프라 </br>

### 공공 클라우드 
: 일반 사용자들에게 공공으로 제공되는 클라우드 인프라 </br>
- aws, Azure 등등

### 하이브리드 클라우드 
: 앞선 것들 중 클라우드 인프라 구성 몇개를 하나로 묶어 마치 하나의 단일 환경인 것처럼 서비스 제공</br>
</br>

클라우드 서비스 모델은 소비자에게 제공되는 기능으로 다섯가지로 나뉨</br>
- Iaas
- Caas
- Paas
- Faas
- Saas
Iaas -> Saas
이렇게 갈 수록 사용자의 책임이 줄어든다</br>
반면 플랫폼의 책임은 늘어난다. </br>
</br>

## 1.2.1 서비스형 인프라스트럭처 IaaS
IaaS모델에서 사용자는 서버, 스토리지, 및 네트워크와 같은 자원을 직접 제어 및 제공가능</br>
- AWS:EC2, Azure:virtual Machine
</br>

## 1.2.2 서비스형 컨테이너 CaaS
CaaS모델에서 사용자는 가상화를 위한 기본 리소스를 제어할 수 없고 대신 컨테이너를 만들고 관리함</br>
클라우드 공급자는 기본 리소스를 제공함: ex-새로운 가상머신을 만들고 인터넷 통한 액세스위해 네트워크 구성해줌</br>
컨테이너 플랫폼 구축위한 도구 : 도커, 쿠버네티스</br>
- Amazon Elastic Kubernetes Service EKS
</br>

## 1.2.3 서비스형 플랫폼 PaaS
클라우드 공급자가 인프라, 도구, API를 제공하고 개발자는 이를 사용해 애플리케이션을 빌드하고 배포함</br>
- ex: 개발자가 빌드 후 JAR 파일로 패키징 후, PaaS 모델로 실행되고 있는 플랫폼에 배포할 수 있음 </br>


## 1.2.4 서비스형 함수 FaaS
FaaS 모델의 서버리스 컴퓨팅을 사용하면 사용자는 함수의 형태로 비즈니스 로직을 구현하는 데만 집중할 수 있음</br>
플랫폼은 서버 및 나머지 인프라 제공</br>
서버리스 애플리케이션은?</br>
HTTP 요청이나 메시지 같은 이벤트 발생시 실행하게끔 할수 있음</br>
- ex: 어떤 데이터가 메시지 큐에 들어올 때마다 특정 알고리즘에 따라 결과를 계산하는 함수도 작성가능
- Amazon aws Lambda

## 1.2.5 서비스형 소프트웨어 SaaS
- 가장 추상화된 서비스
- 소비자는 사용자로서 애플리케이션에 액세스
- 클라우드 공급자는 소프트웨어 및 인프라 스택 전체 관리
- 많은 회사가 애플리케이션 만들고 CaaS 또는 PaaS 모델을 통해 실행 후 최종 고객에게 SaaS 형태로 판매함
- GitHub

</br>

## 클라우드 네이티브 애플리케이션의 특성
클라우드는 준비됨, 그 특성 활용 위해 애플리케이션을 어떻게 설계해야할지 보자</br>
- 확장성 : 워크로드의 증가 또는 감소를 동적지원
- 느슨한 결합 : 각각의 구성 요소들은 서로에 대해 최소한의 지식만 갖음
- 회복성 : 문제 직면 시 서비스 수준 유지
- 유지 보수성 : 외부에서의 제어 수준 : 갱신, 설정, 배포
- 관측 가능성 : 내부 상태에 대해 외부로부터 추정된 지식 

## 1.3.1 확장성 
클라우드 네이티브 애플리케이션은 확장 가능함</br>
: 추가 리소스를 제공해 증가하는 워크로드를 지원함 </br>
- 추가 리소스 특성에 따라 수직적 확장/ 수평적 확장
- 수직적 확장(위/아래 확장) : 하드웨어 리소스 추가(무한정 추가 불가,제한적 방식): 애플리케이션 설계시 명시 필요 없음
- 수평적 확장(확대/축소 확장) : 컴퓨팅 노드/ 컨테이너 추가( 제한없음): 애플리케이션 설계시 확장 가능해야함

전통적인 시스템 : 워크로드 증가 시 수직적 확장 채택(일반적)</br>
클라우드 : 수평적 확장 선호</br>
- 이는 클라우드 컴퓨팅 모델이 제공하는 추상화 수준 덕분에 가능</br>
</br>
클라우드는 탄력적임(리소스를 필요에 따라 늘리거나 줄이기 가능), 확장성은 탄력성을 갖추기 위한 전제 조건</br>
</br>


## 1.3.2 느슨한 결합
goal : 한 컴포넌트가 바뀐다고 해서 다른 부분까지 변경할 필요가 없음</br>
- 시스템을 모듈로 분해(모듈화)
- 의존성 최소화(느슨한 결합)
- 함께 변화하는 코드 캡슐화(높은 응집력)
=> 좋은 설계 방법</br>

파르나스의 모듈화 세가지 이점</br>
- 관리: 각 모듈의 팀들은 서로간의 조정, 의사소통에 많은 시간 할애x
- 제품 유연성 : 독립적으로 진화, 전체 시스템은 유연
- 이해력 : 전체를 이해할 필요 없고 하나의 모듈만 이해하고 작업가능


</br>
-> 마이크로서비스와 관련된 이점 </br>
분산된 모놀리스 : 밀접 결합된 시스템을 MSA로 변경하면 단단 결합된 MSA가 됨(이런것들이 존재함을 암시함-부적절)</br>
모듈식 모놀리스 : </br>

## 1.3.3 복원력
복원력 : 결함이나 환경변화 시에도 허용가능한 수준의 서비스 제공할 수 있도록 하는 기능</br>

클라우드 네이티브 시스템 </br>
구축시 목표 : </br>
장애 발생 시 언제나 사용가능하도록 보장하는 것 (가용성) </br>

우리의 마음가짐: </br>
동적환경에서 실행되는 특성상 결함을 사전에 막을 수 없음/ 변화는 예외적 상황 아닌 일어날 법칙 으로 생각</br>

세가지 필수 개념 :</br>
- 결함: 잘못된 내부 상태를 생성하는 원인 제공 장소 (ex 메서드호출, 널 아닌 반환값 넘겨야 함에도 널 값 반환하는 case)
- 오류: 예상 작동과 실제 작동 간의 불일치(ex 위 언급 결함으로 NullpointerException 발생 case)
- 실패: 결함 촉발 오류 발생 실패, 시스템 응답x , (ex nullException 적절하게 처리 x 실패 유발 시스템은 모든 요청에 500코드응답)

이에 애플리케이션은 내결함성(fault tolerant)을 갖게 설계필수</br>
복원력에서 필수적인 부분:</br>
- 실패 발생 시 다른 부분에 영향x
- 실패 발생 부분은 해결까지 격리 상태 유지

## 1.3.4 관측 가능성
외부 출력에서 내부 상태를 얼마나 잘 추론할 수 있는지 측정한 것</br>
외부 출력: 측정값, 로그, 트레이스(trace)와 같은 데이터</br>

관측 가능성의 네 가지 요소: </br>
- 모니터링: 애플리케이션의 전반적인 상태 정보 얻고 특정 양상 측정(ex Spring Boot Actuator:모니터링 기능, prometheus)
- 경고/시각화: 상태 수집 후 조치 취함, dashBoard 사용해 시각화 후 그래프 표시(ex Grafana 활용법)
- 인프라를 추적하는 분산 시스템: 분산 시스템에서는 모든 서버 내의 작동 뿐만 아니라 서로 다른 서버시스템 사이 데이터 추적 필수(ex OpenTelemetry와 Spring 통합, Grafana Tempo 사용해 트레이스 수집 및 시각화)
- 로그 집계/분석: 시스템 작동에 대한 저 나은 데이터 제공 및 분석(ex Fluent Bit, Loki, Grafana 사용해 로그 수집 및 시각화할 것)

## 1.3.5 관리 용이성
제어이론 : 관측 가능성 ~(대응) 제어 가능성</br>
제어 가능성 : 
- 외부 입력 통해 유한시간 내에 시스템 상태 또는 출력 변경하는 능력(얼마나 쉽고 효율적으로)
=> 이 개념은 관리 용이성으로 이어짐</br>

관리 용이성: </br>
코드를 바꾸지 않고도 애플리케이션의 작동을 수정할 수 있는 능력</br>
클라우드 네이티브 애플리케이션이 코드를 변경하거나 릴리즈를 빌드 않고도 작동을 수정할 수 있도록 설정이 바람직</br>


## 1.4 클라우드 네이티브를 지원하는 문화 및 관행
- 자동화: 재생 가능하고 효율적이며 신뢰할 만한 시스템
- 지속적 전달 : 더 낫고 더 빠른 소프트웨어 배포
- 데브옵스 : 서로 다른 역할 사이에서 협업하는 문화
이렇게 세가지 개념에 대해 논의할 것</br>


## 1.4.1 자동화
자동화: </br>
클라우드 네이티브의 핵심(반복적인 수동작업 자동화해 빠르게 배포하자)</br>
장점: </br>
- 프로세스와 작업이 반복 가능
- 시스템이 안정적이고 신뢰 가능
클라우드 자동화의 두가지 중요 범주: 인프라 제공 및 설정 관리</br>
- 코드형 인프라스트럭처infrastructure as code
- 코드형 설정configuration as code

## 마틴 파울러 _ 코드형 인프라스트럭처
: 다른 시스템 다룰 때와 동일한 방식으로 소스 코드를 통해 컴퓨팅 및 네트워크 인프라를 정의하는 접근방식</br>
: cloud 업체는 편리한API 제공함/ 이를 통해 서버, 네트워크,스토리지 생성가능/ 이 작업을 테라폼도구로 자동화 후 형상관리시스템으로 관리/ 동일한 테스트 및 배포 방법 적용 / => 좀 더 안정적이고 예측 가능한 인프라 얻음 </br>
(ex. 우분투 22.04로 새로운 가상머신 하나 생성)

컴퓨팅 리소스를 생성한 후에는?</br>
리소스 관리와 설정을 자동화할 수 있음 => 코드형 설정: 다른 모든 시스템과 동일한 방식으로 리소스에 대한 설정 정의 방식</br>

(ex. 우분투 생성 후 런타임 환경을 JRE 17로 설치, 방화벽 8080포트 여는 등의 작업 자동화 가능)</br>
이렇게 인프라 생성, 설정 관리 작업을 자동화하면, 불안정하고 신뢰성 떨어지는 서버(스노플레이크 서버) 생성 피함</br>
스노플레이크 서버 : </br>
1. 서버 생성 설정관리 등을 수동으로 하면 동일한 서버 나중에 다시 생성 어려움
2. 변경 가능성 있는 취약한 서버되기 쉬움

피닉스 서버 : </br>
1. 모든 작업 자동화
2. 모든 변경 사항 형상관리 시스템 추적
3. 셋업 언제든지 반복 가능 서버 생성
=> 극단으로 가면 **불가변 서버** 얻을 수 있음 </br>

## 1.4.2 지속적 전달
지속적 전달 : </br>
- 프로덕션 환경에 언제든지 배포할 수 있는 방식으로 구축하는 개발의 한 분야
- 이를 통해 짧은 주기로 기능 구현/ 언제든지 안정적 배포 가능 => 큰영향 미치는 변경을 최소한의 노력으로, 자주 예측가능한 방식으로 가하는 것의 **핵심**   
</br>

## 지속적 통합 CI
지속적 통합 : </br>
지속적 전달의 토대가 되는 관행/ 개발자가 변경사항을 기본 브랜치에 적어도 하루에 한 번 커밋</br>
소스 자동 컴파일/테스트/실행 가능한 아티팩트(JAR 파일, 컨테이너 이미지)로 패키징</br>
=> 변경에 대한 빠른 피드백 얻기 위함 / 오류 감지 시 즉시 수정/ 기본 브랜치는 안정적인 토대가 되어야함</br>

## 지속적 전달 CD 
지속적 전달 : </br>
CI를 기반으로 함/ 기본 브랜치가 배포 가능한 상태 유지에 중점/ 아티팩트는 실행 가능상태/소프트웨어는 서비스환경과 유사한 환경에 배포됨</br>
- 이 과정에서 배포 유효성 검증 위해 여러 테스트 거치며 배포 확신 갖게됨
- 기본 브랜치를 항상 배포 가능한 상태에 두는 것이 목표

배포 파이프라인 : </br>
지속적 전달(CD)은 배포 파이프라인을 통해 전체 프로세스의 자동화를 촉진함</br>
: 기본 브랜치 항상 배포 가능하게 유지위한 배포 파이프라인 구축한다고 생각하면 됨</br>

지속적 배포: </br>
지속적 전달을 지속적 배포와 혼동하는 경우 종종</br>
but, 지속적 전달은 배포 가능한지 확인 필요로 함 지속적 배포는 변경된 사항을 프로덕션에 자동 배포함 </br>
</br>
</br>
#2 </br>

## 1.4.3 데브옵스
데브옵스는 클라우드 네이티브로 전환될 때 파악해야할 중요한 개념</br>
> 데브옵스 : 지위나 배경에 관계없이 사람들이 시스템을 구상, 개발, 배포 및 운영하기 위해 함께 협력하는 문화

: 데브옵스는 문화다. 개발 배포 운영 위해 협력하는 문화</br>

- 데브옵스는 노옵스NoOps를 의미하지 않는다.
: 개발자가 운영을 담당한다고 운영자의 역할이 사라진다고 생각하는 실수할 수 있음 하지만 공동작업임</br>

- 데브옵스는 도구가 아니다.
: 도커, 쿠버네티스 같은 툴이 데브옵스 툴이다? -> x </br>
: 데브옵스는 하나의 문화임 툴을 사용한다고 해서 데브옵스 조직이 될 수 없음</br>

- 데브옵스는 자동화가 아니다.
: 자동화가 데브옵스의 필수 부분이긴함, 그래도 = 은 아님 </br>
: 데브옵스는 지속적 전달과 같은 프로세스 중 일부 자동화 가능 </br>
  (아이디어에서 생산까지 함께 작업하는 개발자와 운영자에 관한 것)</br>

- 데브옵스는 역할이 아니다.
: 우리가 데브옵스를 올바르게 생각하면 데브옵스의 역할을 이해하기 어렵다. 그런데! 역할이 아님에도! 데브옵스 엔지니어에 대한 요청 증가중 ~ </br>

- 데브옵스는 팀이 아니다.
: 만약 데브옵스를 잘못 이해한다면 데브옵스 팀으로 운영팀을 대체할 수도ㅋ(아님 새로 추가할 수도) </br>

데브옵스가 개발자와 운영자에 관한 것이라 했음, </br>
클라우드 네이티브로 옮겨갈 때 개발자와 운영자간의 협력이 가장 중요함=> 데브옵스랑 관련 있는 것 </br>
</br>
근데 개발자와 운영자만 책임있는게 아니고 테스터 및 보안전문가들 모두 책임이있고 지속적 전달이라는 목표 달성위해 모두 중요한 존재임</br>


## 1.5 클라우드가 최선의 선택인가?
업계의 큰 실수 중 하나 : 새로운 기술을 모든 사람들이 언급한다는 이유 만으로 그것을 채택함 </br>
근데 말이야. 시스템이 클라우드 네이티브를 통해 해결하려는 문제점 없고, 그런 속성이 필요 없다면 클라우드 네이티브는 최적의 방안 아님 </br>

- 특정 기술, 접근 방식이 문제를 해결할 수 있는 지 파악이 핵심

언제, 왜 클라우드 네이티브 방식을 채택해야 할까?</br>
- 비전에 클라우드 네이티브 주요 목표인 속도, 확장성, 복원력 및 비용이 목표로 포함되어 있음
- 클라우드 기술로 해결하려는 문제점을 가지고 있음
하지만 이런 상황이 아니라면, 클라우드를 사용하지 않는 것이 오히려 조아</br>
ex. 모놀리스가 10년 동안 잘 작동해 왔으면, 클라우드 굳이 ?

> 클라우드 네이티브로 옮겨갈 때 속도, 복원력, 확장성, 및 비용 최적화를 달성하려는 목표 가짐


## 1.5.1 속도 
소프트웨어를 더 신속하게 출시 => 경쟁에서의 우위 </br>
고객들은 버그 수정 및 더 많은 기능을 당.장. 해주길 바람</br>

- 신속/빈번 출시
- 고객에게 더빠른 피드백(피드백 루프 짧아짐)
- 새로운 기능 관련 위험 감소 ( 몇달 거쳐 완벽? ㄴㄴ 바로출시 고객 피드백 받아 기대 부응)
- 작은 릴리스는 변경사항 작아 실패 가능성 작음

전통적인 개발 방식 : 대규모 릴리스, 유연성 부족, 늘어진 출시 사이클 </br>
=> (자동화 된 작업, 지속적 전달과 같은) 클라우드 네이티브 접근방식 통한다면 기업은 출시 시간 단축 가능 </br>


## 1.5.2 복원력 
모든 것은 변하고 실패는 항상 일어나기에, 변화는 예외가 아니라 상수(변하지 않는 수)다.</br>
복원력이 좋다?</br>
- 잘못된 일이 발생하더라도 서비스 계속 제공
- 문제 해결과정이 다운타임 없이 수행

클라우드 기술을 통해 "복원력 높은" 클라우드 네이티브 애플리케이션 사용 가능 => 가용성/복원력 높기 원함?</br>
: 클라우드 네이티브는 GOOD 선택 </br>


## 1.5.3 확장성 
앞으로 일어날 일 예측 => 어려움/ 확장 가능 기능으로는 no 충분 => 상황에 따라 동적으로 확장 할 수 있어야함 </br>
: 부하 up _ 동적/신속/어려움 없이 확장 가능해야 함 / 부하 down _ 인스턴스 줄이기</br>

비즈니스가 고객에게 신속/효율적 적응 필요로 한다면?(유연성 필요)=> </br>
클라우드 네이티브 애플리케이션과 클라우드와 결합해 사용하면 탄력성 확보 가능 </br>


## 1.5.4 비용
클라우드 컴퓨팅 모델은 탄력성과 온디맨드 사용당 지불 정책으로, IT 인프라 비용 최적화에 도움</br>
- 실제 사용한 만큼만 지불하고, 필요 없는 자원은 회수
- 클라우드 네이티브 방식 채택 시 비용 최적화 가능
: 클라우드 네이티브 애플리케이션은 탄력성 활용 위해 확장 가능토록 설계 => 복원력 높아 => 다운타임, 시스템 실패 관련 비용 감소</br>

## 1.6 클라우드 네이티브 구성 
지금까지 클라우드 네이티브 관련 특정 기술이나 아키텍처를 언급 x </br>
=> 애플리케이션을 클라우드 네이티브로 만들기 위해 "반드시" 도커 컨테이너를 사용할 필요 없음 </br>

이번 절에서는?</br>
- 클라우드 네이티브 일반적인 구성 몇 가지(컨테이너와 오케스트레이션의 개념)
- 서버리스 기술 및 함수(FaaS)

구성 : </br>
- 컨테이너 : 경량화되고 독립적인 컴퓨팅 콘텍스트
- 오케스트레이션 : 컨테이너 스케줄링, 클러스터 관리
- 서버리스 : 클라우드 플랫폼에서 관리되는 서버와 백엔드 서비스
: 클라우드 네이티브 컴퓨팅의 주된 모델은 (오케스트레이터가 관리하는) '컨테이너'와 '서버리스'다.</br>


## 1.6.1 컨테이너 
가정 해보자. 어떤 팀에 '합류해' 작업을 시작한다. </br>
- 로컬 개발 환경 갖추기
- 기능 개발 후 QA 환경 테스트
- 스테이징 환경 배포 및 최종 프로덕션 배포
: 중요한 건, 앞선 모든 환경을 가능한 한 비슷하게 유지하는 것</br>
=> 그러기 위해서는 컨테이너가 필요</br>

컨테이너 이전에는?</br>
: 가상 컴퓨터에 의존 => 가상화는 하이퍼바이저 요소 활용해 (하드웨어를 추상화하는) 동일 시스템에서 여러 운영체제 독립 실행 가능함 </br>
: 하이퍼바이저는 기계 하드웨어/ 또는 호스트 운영체제에서 직접 실행됨 </br>

반면 OS 컨테이너는 ?</br>
- 내부에서 애플리케이션 실행하기 위해 필요한 모든 것을 가지고 있는 경량 실행 파일 패키지
- 컨테이너는 호스트와 커널을 공유함 (커널 : 컴퓨터 운영 체제의 핵심이 되는 컴퓨터 프로그램으로, 시스템의 모든 것을 완전히 제어(control)함)
- 때문에, 새로운 컨텍스트 추가위해 전체 운영체제를 부트스트랩할 필요 없음 (부트스트랩: 시스템 부팅시 실행되는 코드)_ 리눅스에서는 리눅스 커널 제공 기능 몇가지만 사용하면 됨

 리눅스 커널 제공 기능 2가지 </br>
 - 네임스페이스 : 리눅스에서 프로세스를 격리 시킬 수 있는 가상화 기술
프로세스 간 리소스를 분할=> 자원의 종류 제한 => 시스템에서 사용할 수 있는 리소스를 일부만 볼 수 있기위함</br>
- c그룹 : 프로세스에 대한 리소스 사용제어 및 제한

> NOTE: 컨테이너는 동일한 커널 공유/ 가상화만 사용하는 경우 하드웨어 공유 => 격리의 정도만 차이, 격리된 상태에서 소프트웨어 실행하기 위한 컴퓨팅 환경을 제공함

</br>

> NOTE: 가상화에서 가상머신은 하드웨어만 공유하고 컨테이너화의 컨테이너는 운영체제 커널도 공유함_ 컨테이너가 더 가볍고, 이식성 good
</br>
</hr>
</br>

![image](https://github.com/hansun-hub/CloudNativeSpringInAction/assets/68306239/a9e99b9f-cbff-463e-aed7-6bfb710ed33b)

</br>
보안적인 관점에서도 컨테이너 방식이 우수</br>

- 운영체제 Bug:
가상화환경에서 사용자가 자기 맘대로 권한을 가지고 간섭을 받고 싶어하지 않는 상황이라면</br>
버그를 지우려 엑세스 하는 것 조차 어려울 수도 </br>

- App 취약점: </br>
App1이 guest OS 위에서 구동 중 </br>
내쫒을 수 있나? => 좀 복잡한 문제가 됨, 관리 권한 문제에 있어서도</br>

</hr>
</br>
클라우드 네이티브 애플리케이션에서 컨테이너는 왜 인기 많음?</br>
: 전통=가상 컴퓨터에 자바 런타임 환경 JRE, 미들웨어 설치하고 유지관리 해야하는데</br>
컨테이너= 그런거 없이 모든 환경에서 실행가능 </br>
</br>
=> 결론 : 컨테이너는 다양한 환경 이식성 뛰어나고 가볍고, 리소스 덜 사용 => 동적으로 신속히 확장해야 하는 클라우드에 사용하기 갓벽 </br>
가상머신은? 들어가는 비용 크고 시간도 많이 소요 </br>
</br>
그래도 알아야 할것 </br>
: 가상화와 컨테이너가 상호 배타적인 관계는 아니다는거 둘 다 사용할 수도 있다 .</br>
- IaaS 모델은 가상서버임에도 컨테이너 설치해서 같이 사용 가능
- CaaS 모델은 컨테이너 모델임에도 여전히 가상화가 존재함 
=> 상호 배타적인 관계 아니다. </br>


## 1.6.2 오케스트레이션 
컨테이너 사용의 장점 : </br>
- 컨테이너의 높은 이식성
- 컨테이너 반복 생성 쉬움
- 가볍고 신속 확장 가능

이런 장점이 있는 컨테이너를 사용하는 클라우드 네이티브 시스템으로 차기 프로젝트를 개발한다면 모든 준비가 된 것일까?</br>
</br>
: 단일 서버에서 생성 및 관리는 간단, 하지만 수백개의 컨테이너를 여러 대의 서버에 배포 및 처리 위해선 다른 무언가 필요 </br>
IaaS에서 CaaS로 넘어갈 때 변화 : </br>
IaaS에서는 가상 서버인 단일 컴퓨팅 노드에 중점/ CaaS에서는 토대가 되는 인프라를 추상화해 노드 클러스터에 중점</br>
CaaS가 제공하는 관점:</br>
- 배포 대상은 하나의 서버가 아니라 여러서버로 이루어진 클러스터가 됨
- CaaS 플랫폼 (쿠버네티스가 기반)은 여러 서버에서 실행되는 컨테이너들 조정orchestrating 하면서 발생하는 문제들 해결위해 많은 기능 제공

> 컨테이너의 배포 대상 : 서버 / 오케스트레이터의 배포 대상 : 클러스터

컨테이너 오케스트레이션은 다음 작업들을 자동화하는데 도움 </br>
- 머신 생성 삭제
- CPU 및 메모리 스케줄링 및 배포
- 컨테이너 동적 확장 및 모니터링
- 컨테이너 서로 통신 위해 네트워크 설정
- 네트워크 구축
- 자원 할당
- 액세스 제어 정책 시행

오케스트레이션 툴에 대한 명령은 선언적으로 이루어짐</br>
- YAML 파일 통해 수행됨
- 달성하고자 하는 상태를 기술함
ex. 클러스터에 웹 컨테이너 세 개 배포하고 이 서비스 인터넷 통해 제공: 이것이 달성 상태 예시 </br>

</br>

## 1.6.3 서버리스 
서버리스 기술을 사용한다고?</br>
전제 : 가상머신에서 컨테이너로 이동 
- 클라우드 서비스가 제공하는 추상화 계층을 한층 더 늘려 서버리스 기술 사용 가능

</br>
- 쿠버네티스 같은 오케스트레이터 사용할 때:
인프라생성, 용량, 확장 측면 고려 필요 </br>
- BUT, 서버리스 플랫폼은
실행할 애플리케이션이 필요한 모든 인프라 작업을 대신 처리해줌 </br>
</br>
서버리스 아키텍처의 두 가지 모델</br>
: 병행 사용 많다.</br>

### 서비스형 백엔드 backend as a service, BaaS
- 클라우드 공급자가 제공하는 '타사 서비스'에 크게 의존하는 애플리케이션
타사 서비스 : 데이터베이스, 인증 서비스, 메시지 큐
- 개발 및 운영 비용 줄이는데 중점
- 백엔드 개발 기능 대부분 BaaS 업체에 일임하고 프런트엔드 애플리케이션 구현가능
  ex. 구글 파이어베이스 사용한 데이터 저장, 아마존 API 게이트 웨이 사용해 REST API 제공하고 관리 </br>

### 서비스형 함수 function as a service, FaaS
- 이벤트에 의해 실행되며 플랫폼이 전적으로 관리하는 애플리케이션 </br>
- 오케스트레이션 및 확장 관련 비용 줄이는데 중점
- 플랫폼이 나머지 처리하는 동안 개발자는 비즈니스 로직 구현 가능
두가지 유형으로 제공됨</br>
- 1. 공급자 제공 FaaS 플랫폼 사용 (AWS 람다 함수, 애저함수,,)
- 2. 오픈소스 프로젝트 기반으로하는 서버리스 플랫폼 사용 => 공급업체 의존x, 제어 권한 획득( 케이네이티브,..)

서버리스 특징 </br>
1. 비용 최적화 </br>
- 이벤트 기반 : HTTP요청 과 같은 처리할 이벤트 있을 때만 실행
- 처리 할 거 없으면 모든 리소스 종료 => 실제 사용한 것만 비용 지불 가능
> 서버리스 플랫폼 주요 기능 : '제로 스케일링scaling to zero' 

2. 제어 권한 및 책임의 범위 훼손
- 서버리스 사용시, 어느 정도의 통제 권한 갖고 싶은지, 공급업체에 대한 의존성 어떻게 처리할 것인지 고려해야함 
- 특정 플랫폼에서 함수를 작성하면 컨테이너와 다르게 다른 플랫폼으로 옮기는 것 어려움
=> FaaS 사용시 제어 권한 및 이식성의 책임과 범위 훼손 될 수도 (반면, 쿠버네티스는 쉽게 옮기기 가능)


## 1.7 클라우드 네이티브 애플리케이션을 위한 아키텍처 
클라우드 네이티브의 내부에 무엇이 있는 지 살펴보고 </br>
클라우드 네이티브 애플리케이션의 설계와 디자엔에 관한 원칙 몇가지 보겠음 </br>
주요 개념 : </br>
- 애플리케이션 서비스 : 느슨히 결합, 독립적으로 배포할 수 있는 단위
- 데이터 서비스 : 데이터베이스, 메시징 시스템 등 상태 유지하는 구성요소
- 상호작용 : HTTP, RSocket 과 같은 서비스간 통신

## 1.7 다중 계층에서 마이크로 서비스 아키텍처까지 그리고 그 이후
애플리케이션이 설계되고 디자인되는 방식 : </br>
- 모놀리스 애플리케이션: 거대한 메인 프레임에 단일 구성요소로 배포되는 방식
- 다중 계층 아키텍처 : 클라이언트/서버 패러다임에 따라 설계하는 방식에 의존하는 => 널리 사용됨

애플리케이션이 복잡/ 민첩성 필요해짐 => 코드 세분화 방법 모색 : 마이크로서비스 등장 </br>
- 모놀리스 대 마이크로 서비스
: 모놀리스 = 다층구조/ 마이크로서비스 = 독립적으로 배포할 수 있는 여러 구성요소로 이루어짐</br>
: 가장 큰 차이점은? </br>
애플리케이션이 어떻게 분리되는 지 .</br>
모놀리스 = 세개의 큰 계층 사용/ 마이크로서비스 = 각각 하나의 기능만을 구현하는 요소가 여러개</br>

제안 : 모놀리스를 마이크로서비스로 나눠서 복잡성 해결하자 </br>

</hr>
</br>
매크로서비스 : </br>
구성요소의 수를 줄임으로서 복잡성 줄이고자 </br>
시타델 아키텍처(중앙에 모놀리스, 그 주위 마이크로서비스)/ 다시 모놀리스로 돌아가 등등..</br>
</br>
결국 중요한건... 고객/비즈니스에 가치 전달할 수 있는 아키텍처를 선택하는 것 </br>
아키텍처에 일률적인 해결책은 없음 => 모놀리스와 마이크로서비스 사이에 다툼 있을 필요 없음</br>
</hr>
</br>
결론: 클라우드 네이티브 애플리케이션은 마이크로 서비스와 동일하게 분산 시스템 </br>
      클라우드 네이티브 애플리케이션은 느슨하게 결합 되어 있으며  이는 마이크로 서비스의 특징 </br>

하지만 이 둘은 동일한 것은 아니며, 클라우드 네이티브 애플리케이션에서 마이크로 서비스 스타일을 꼭 사용해야만 하는 것도 아님 </br>



## 1.7.2 클라우드 네이티브 애플리케이션을 위한 서비스 기반 아키텍처 
우리가 구축할 시스템의 아키텍처는 서비스와 상호작용 두 가지 요소로 나뉨</br>

- 서비스 : 서비스를 제공하는 구성 요소
- 상호작용 : 서비스간 통신
서비스 분류 기준 :  상태를 저장하는지</br>

</hr>
- 애플리케이션 서비스 : 상태를 갖지 않는다.
- 데이터 서비스 : 상태를 갖는다.

애플리케이션 서비스: </br>
상태를 갖지 않으며, 논리를 구현함</br>
느슨한 결합, 높은 응집력을 고려하여 설계해야함</br>
독립적 이어야 한다.</br>

데이터 서비스 : </br>
상태를 가짐/ ex. DB, redis, mq</br>

</br>
상호작용 :</br>
이벤트 기반 접근 방식 - 복원력 좋음</br>
요청/응답 패턴(동기식 http 호출)</br>


## 요약
- 클라우드 네이티브 애플리케이션은 클라우드를 위해 설계되고, 상주하는 분산된 시스템이다.
- 클라우드는 상품으로 제공되는 IT인프라이다.
- 클라우드는 사용하는 리소스에 대해서만 비용을 지불한다.
- 클라우드는 IaaS, CaaS, PaaS, FaaS, SaaS와 같이 추상화 수준에서 서비스를 제공한다.
- 클라우드 네이티브 애플리케이션은 수평적 확장, 느슨한 결합, 응집력, 결함에 잘 견디고, 관리 및 관찰 가능하다.
- 클라우드 네이티브개발은 자동화, 지속적 전달, 데브옵스에 의해 지원된다.
- 데브옵스는 서로 다른 역할 간의 협업을 통해 비지니스 가치를 제공하는 문화이다.
- 컨테이너는 클라우드 네이티브 시스템을 위한 컴퓨팅 단위로 사용 된다.
- 가상머신보다 가볍고, 이식성, 불변성, 유연성을 제공한다. (도커)
- k8s 같은 플랫폼을 통해 컨테이너를 관리하며, 오케스트레이션, 클러스터 관리 네트워크 서비스 및 스케줄링 한다.
- 서버리스는 플랫폼이 서버&인프라 를 관리하고, 개발자는 비지니스 로직에만 집중하는 모델이다.
- 마이크로서비스는 클라우드 네이티브 애플리케이션을 구축하는 데 사용할 수 있지만, 필수 사항은 아니다.


</br>

</br>

