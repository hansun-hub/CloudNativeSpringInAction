<주요 내용></br>
- 클라우드 네이티브 프로젝트의 부트스트래핑
- 임베디드 서버와 톰캣을 사용한 작업
- 스프링 MVC를 사용한 RESTful 애플리케이션 구축 
- 스프링 테스트를 사용한 RESTful 애플리케이션 테스트 
- 깃허브 액션을 사용한 빌드 및 테스트 자동화 

</br>

## 3.1 클라우드 네이티브 프로젝트의 부트스트래핑

15요소 방법론에는 몇 가지 실용적인 지침있음 </br>
- 하나의 코드베이스, 하나의 애플리케이션 
: 형상관리 시스템을 통해 하나의 코드베이스로 관리해야함 </br>
- 의존성 관리 
: 의존성을 명시적으로 관리하는 도구 사용해야함 / 암시적 의존성을 기대하지 말것 </br>
</br>
이 두가지 원칙에 대해 논의해보자 </br>
</br>

## 3.1.1 하나의 코드베이스, 하나의 애플리케이션 

클라우드 네이티브 애플리케이션은 깃과 같은 형상 관리 시스템을 통해 단일한 코드베이스로 관리해야함 </br>
: 각 코드베이스는 여러 환경에 배포할 수 있는 불가변 아티팩트, 즉 빌드를 생성해야함 </br>
(각 애플리케이션은 코드베이스가 있으며, 이 코드베이스에서 생성된 불가변 빌드가 코드 수정없이 각각의 환경에 배포됨)</br>

</br>

## 3.1.2 그래들과 메이븐의 의존성 관리 
애플리케이션에서 의존성을 어떻게 관리할지는 => 중요한 문제다 ! </br>
자바 생태계에서 의존성 관리를 위해 가장 많이 사용하는 도구는? </br>
- 그래들 
- 메이븐 
</br>
둘 다 </br>
매니페스트 파일에 의존성 선언/ 중앙 저장소에서 다운로드할 수 있는 기능 제공 </br>
=> 프로젝트에 필요한 모든 의존성을 명시적으로 나열하는 이유는 ?? </br>
: 애플리케이션이 실행되는 환경이 어떤 라이브러리를 제공할 줄 알았더니 제공 하지 않는 상황을 방지 하기 위함임 </br>
</br>
다시 폴라복숍 예제로 넘어가보자. </br>
폴라복숍에서, 애플리케이션에 필요한 모든 의존성 라이브러리는 자동 생성된 build.gradle 파일 (catalog-service/buid.gradle)에 열거되어 있음 </br>
</br>
여기에서 두 가지의 의존성 라이브러리가 필요함 </br>
- 스프링 웹 
: 스프링 MVC로 웹 애플리케이션을 구축하는데 필요한 라이브러리 제공, 톰캣을 임베디드 서버로 포함하도록 기본설정되어잇슴</br>
- 스프링 부트 테스트 
: 모든 스프링 부트 프로젝트에 자동으로 포함 </br>
</br>
=> 스프링 부트의 가장 큰 특징 중 하나는 : 의존성 관리를 처리하는 방식 </br>
- spring-boot-starter-web 같은 스타터 의존성 라이브러리 덕분에 => 의존성 관리 x, 특정 버전이 서로 호환되는지 확인 x

</br>
</br>

## 3.2 임베디드 서버로 작업 
스프링 부트를 사용하면 다양한 유형의 애플리케이션 제작 가능(웹, 이벤트 중심, 서버리스, 배치..)</br>
이들 모두는 몇 가지 "공통된" 측면을 공유하는데 ... </br>
- 1) 런타임 외에는 외부 의존성을 갖지 않은 채 완전히 "독립적임"
- 2) 표준적이고 "실행 가능한" 아티팩트로 패키징 됨

✔ 공통된 측면의 예시를 볼까 ? 웹 애플리케이션을 생각해보자 ! </br>
: 전통적인 방법은 WAR 파일로 패키징한 후에 톰캣과 같은 웹 서버에 배포한다.=> (표준적이고 실행가능한 아티팩트로 패키징됨)</br>
: 여기에서 서버에 대한 외부 의존성을 갖게 되면 애플리케이션 자체의 이식성 및 발전 제한/ 유지 보수 비용 증가 => 때문에 외부 의존성 갖지 않은 채 독립적 </br>

</br>
이번 절에서는 여러가지 살펴볼건데, 서버, 포트 바인딩, 동시성에 관한 15요소 방법론의 몇가지 지침에 대해서 자세히 볼 것 . </br>
- 포트 바인딩 
: 기존 애플리케이션은 실행 환경이 제공하는 외부 서버에 의존하지만 /클라우드 네이티브 애플리케이션은 독립적이므로 ! </br>
환경에 따라 설정 가능한 포트로 바인딩해서 서비스를 외부로 제공 가능 </br>
</br>
- 동시성 
: 사용할 수 있는 여러 스레드를 스레드 풀에 두고 동시성을 처리함 </br>

</br>
이러한 원칙에 따라 우리의 카탈로그 서비스를 1) 독립적이고, 2) 실행가능한 JAR로 패키징 함 </br> 
</br>
</br>

## 3.2.1 실행가능한 JAR 및 임베디드 서버 

전통적인 접근법/ 클라우드 네이티브 접근법 차이 중 하나는 </br>
: 애플리케이션을 패키징하고 배포하는 방법 ! </br>
</br>

- 전통적인 방식
: 애플리케이션 서버나 독립형 웹 서버가 사용됐음 </br>
</br>
=> 유지비용 높음 => 효율성 위헤 여러개의 애플리케이션을 패키징해서 배포 </br>
=> 애플리케이션이 서로 얽매여있음 => 민첩성에 제한 </br>
또한, 애플리케이션 배포가 다양한 환경에서 이식성 제한됐음 </br>
</br>

- 클라우드 네이티브 방식
: 클라우드 네이티브 방식은 다름 ! 독립적이기 때문에 서버에 의존 않고 ! </br>
특히, 스프링 부트는 서버 기능을 내장함으로써 => 외부 의존성 제거/ 독립적 </br>
: 스프링 부트에는 톰캣 서버가 미리 설정되어 번들로 제공됨 </br>

</br>
=> => 서버 의존성 문제 해결 </br>
</br>
그러면 애플리케이션 패키징은?</br>
: JVM 생태계에서 "클라우드 네이티브 애플리케이션"은 "JAR 아티팩트"로 패키징됨 </br>
: "스프링 부트는 JAR 및 WAR 유형의 패키지 둘 다 가능(유연하넹)</br>
: but, "클라우드 네이티브 애플리케이션"은 팻 JAR, 우버 JAR (독립적 JAR) 사용함 </br>
</br>
이 안에는 ? </br>
: 애플리케이션, 의존성 라이브러리 및 임베디드 서버가 모두 포함 되어있음 </br>
</br>
아래는 전통적인 방식과 클라우드 네이티브 방식 비교 </br>

![image](https://github.com/user-attachments/assets/0b396024-0e95-481b-8af1-bd57b5b509a1)

</br> 
- 전통적 : 
애플리케이션은 WAR로 패키징하여 싱행 환경에 서버를 사용해 실행됨 </br>
- 클라우드 네이티브 애플리케이션 : 
JAR로 패키징하여 독립적이며 내장된 서버 사용함 </br>
</br>







