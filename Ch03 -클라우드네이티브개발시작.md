<주요 내용></br>
- 클라우드 네이티브 프로젝트의 부트스트래핑
- 임베디드 서버와 톰캣을 사용한 작업
- 스프링 MVC를 사용한 RESTful 애플리케이션 구축 
- 스프링 테스트를 사용한 RESTful 애플리케이션 테스트 
- 깃허브 액션을 사용한 빌드 및 테스트 자동화 

</br>

## 3.1 클라우드 네이티브 프로젝트의 부트스트래핑

15요소 방법론에는 몇 가지 실용적인 지침있음 </br>
- 하나의 코드베이스, 하나의 애플리케이션 
: 형상관리 시스템을 통해 하나의 코드베이스로 관리해야함 </br>
- 의존성 관리 
: 의존성을 명시적으로 관리하는 도구 사용해야함 / 암시적 의존성을 기대하지 말것 </br>
</br>
이 두가지 원칙에 대해 논의해보자 </br>
</br>

## 3.1.1 하나의 코드베이스, 하나의 애플리케이션 

클라우드 네이티브 애플리케이션은 깃과 같은 형상 관리 시스템을 통해 단일한 코드베이스로 관리해야함 </br>
: 각 코드베이스는 여러 환경에 배포할 수 있는 불가변 아티팩트, 즉 빌드를 생성해야함 </br>
(각 애플리케이션은 코드베이스가 있으며, 이 코드베이스에서 생성된 불가변 빌드가 코드 수정없이 각각의 환경에 배포됨)</br>

</br>

## 3.1.2 그래들과 메이븐의 의존성 관리 
애플리케이션에서 의존성을 어떻게 관리할지는 => 중요한 문제다 ! </br>
자바 생태계에서 의존성 관리를 위해 가장 많이 사용하는 도구는? </br>
- 그래들 
- 메이븐 
</br>
둘 다 </br>
매니페스트 파일에 의존성 선언/ 중앙 저장소에서 다운로드할 수 있는 기능 제공 </br>
=> 프로젝트에 필요한 모든 의존성을 명시적으로 나열하는 이유는 ?? </br>
: 애플리케이션이 실행되는 환경이 어떤 라이브러리를 제공할 줄 알았더니 제공 하지 않는 상황을 방지 하기 위함임 </br>
</br>
다시 폴라복숍 예제로 넘어가보자. </br>
폴라복숍에서, 애플리케이션에 필요한 모든 의존성 라이브러리는 자동 생성된 build.gradle 파일 (catalog-service/buid.gradle)에 열거되어 있음 </br>
</br>
여기에서 두 가지의 의존성 라이브러리가 필요함 </br>
- 스프링 웹 
: 스프링 MVC로 웹 애플리케이션을 구축하는데 필요한 라이브러리 제공, 톰캣을 임베디드 서버로 포함하도록 기본설정되어잇슴</br>
- 스프링 부트 테스트 
: 모든 스프링 부트 프로젝트에 자동으로 포함 </br>
</br>
=> 스프링 부트의 가장 큰 특징 중 하나는 : 의존성 관리를 처리하는 방식 </br>
- spring-boot-starter-web 같은 스타터 의존성 라이브러리 덕분에 => 의존성 관리 x, 특정 버전이 서로 호환되는지 확인 x

</br>
</br>

## 3.2 임베디드 서버로 작업 
스프링 부트를 사용하면 다양한 유형의 애플리케이션 제작 가능(웹, 이벤트 중심, 서버리스, 배치..)</br>
이들 모두는 몇 가지 "공통된" 측면을 공유하는데 ... </br>
- 1) 런타임 외에는 외부 의존성을 갖지 않은 채 완전히 "독립적임"
- 2) 표준적이고 "실행 가능한" 아티팩트로 패키징 됨

✔ 공통된 측면의 예시를 볼까 ? 웹 애플리케이션을 생각해보자 ! </br>
: 전통적인 방법은 WAR 파일로 패키징한 후에 톰캣과 같은 웹 서버에 배포한다.=> (표준적이고 실행가능한 아티팩트로 패키징됨)</br>
: 여기에서 서버에 대한 외부 의존성을 갖게 되면 애플리케이션 자체의 이식성 및 발전 제한/ 유지 보수 비용 증가 => 때문에 외부 의존성 갖지 않은 채 독립적 </br>

</br>
이번 절에서는 여러가지 살펴볼건데, 서버, 포트 바인딩, 동시성에 관한 15요소 방법론의 몇가지 지침에 대해서 자세히 볼 것 . </br>
- 포트 바인딩 
: 기존 애플리케이션은 실행 환경이 제공하는 외부 서버에 의존하지만 /클라우드 네이티브 애플리케이션은 독립적이므로 ! </br>
환경에 따라 설정 가능한 포트로 바인딩해서 서비스를 외부로 제공 가능 </br>
</br>
- 동시성 
: 사용할 수 있는 여러 스레드를 스레드 풀에 두고 동시성을 처리함 </br>

</br>
이러한 원칙에 따라 우리의 카탈로그 서비스를 1) 독립적이고, 2) 실행가능한 JAR로 패키징 함 </br> 
</br>
</br>

## 3.2.1 실행가능한 JAR 및 임베디드 서버 

전통적인 접근법/ 클라우드 네이티브 접근법 차이 중 하나는 </br>
: 애플리케이션을 패키징하고 배포하는 방법 ! </br>
</br>

- 전통적인 방식
: 애플리케이션 서버나 독립형 웹 서버가 사용됐음 </br>
</br>
=> 유지비용 높음 => 효율성 위헤 여러개의 애플리케이션을 패키징해서 배포 </br>
=> 애플리케이션이 서로 얽매여있음 => 민첩성에 제한 </br>
또한, 애플리케이션 배포가 다양한 환경에서 이식성 제한됐음 </br>
</br>

- 클라우드 네이티브 방식
: 클라우드 네이티브 방식은 다름 ! 독립적이기 때문에 서버에 의존 않고 ! </br>
특히, 스프링 부트는 서버 기능을 내장함으로써 => 외부 의존성 제거/ 독립적 </br>
: 스프링 부트에는 톰캣 서버가 미리 설정되어 번들로 제공됨 </br>

</br>
=> => 서버 의존성 문제 해결 </br>
</br>
그러면 애플리케이션 패키징은?</br>
: JVM 생태계에서 "클라우드 네이티브 애플리케이션"은 "JAR 아티팩트"로 패키징됨 </br>
: "스프링 부트는 JAR 및 WAR 유형의 패키지 둘 다 가능(유연하넹)</br>
: but, "클라우드 네이티브 애플리케이션"은 팻 JAR, 우버 JAR (독립적 JAR) 사용함 </br>
</br>
이 안에는 ? </br>
: 애플리케이션, 의존성 라이브러리 및 임베디드 서버가 모두 포함 되어있음 </br>
</br>
아래는 전통적인 방식과 클라우드 네이티브 방식 비교 </br>

![image](https://github.com/user-attachments/assets/0b396024-0e95-481b-8af1-bd57b5b509a1)

</br> 
- 전통적 : 
애플리케이션은 WAR로 패키징하여 싱행 환경에 서버를 사용해 실행됨 </br>
- 클라우드 네이티브 애플리케이션 : 
JAR로 패키징하여 독립적이며 내장된 서버 사용함 </br>
</br>



클라우드 네이티브 애플리케이션에 사용되는 내장서버는 ... </br>
- 웹 서버 구성 요소와 실행 콘텍스트로 이루어짐
- 이를 통해 자바 웹 애플리케이션이 웹 서버와 상호작용 하는 것

</br>
다시 카탈로그 서비스로 돌아와서 ! </br>
: JAR 패키지 옵션 선택햇음 -> 그래들 bootRun 작업 => 애플리케이션 실행 완 ! </br>
근데 이제, 임베디드 서버와 JAR 패키지 대해 </br>
더 많이 알게 됐으니 다른 방법 보자 ! </br>
</br>
</br>
먼저 ! => 애플리케이션을 JAR파일로 패키징 해보자 !  </br>
터미널 창을 열고 카탈로그 서비스 프로젝트의 루트 폴더로 이동 - 명령어 입력 </br>

$ ./gradlew bootJar
</br>
인텔리제이 IDEA가 만료됨..</br>

<img width="456" alt="image" src="https://github.com/user-attachments/assets/c7e6f664-e7f4-4010-b7ff-a14541afaa48">

</br> 
bootJar 작업은 코드를 컴파일하고 애플리케이션을 JAR파일로 패키징함 ! 이때 JAR은 build/libs 폴더로 생성됨 (기본설정)</br>
JAR 파일이 만들어졌으면 표준 자바 애플리케이션처럼 실행해보자! </br

</br>
<img width="784" alt="image" src="https://github.com/user-attachments/assets/59a0d33a-b822-4756-888b-aa3d903e475b">

</br>
프로젝트 처음 생성할 때 web 의존성 추가 했었다. 때문에, 스프링 부트는 내장 톰캣 서버를 자동으로 구성함 </br>
=> 로그 확인시, 최초의 실행 단계중 하나가 애플리케이션 자체 포함 톰캣서버의 인스턴스를 초기화하는 것임 </br>

</br>

## 3.2.2 요청당 스레드 모델 이해 
HTTP상 동기식 상호작용 생각해보면 </br>
클라이언트 -> 서버 (HTTP 요청)/ 서버 -> 클라이언트 (계산 수행 후 HTTP응답을)</br>
</br>
톰캣과 같은 "서블릿 컨테이너"에서 실행되는 애플리케이션은 => "요청당 스레드" 모델 기반 처리함 </br>
- 각 요청에 대해 특정 요청에 전념하는 스레드 할당
- 그 스레드는 응답 반환까지 그 목적으로만 사용됨

:ex. I/O작업 처리시 스레드는 기다림 .. => 동기화 처리, 블로킹 처리라고 불리는 이유 </br>

</br>
"스레드 풀" </br>
: 톰캣은 스레드 풀을 초기화해서 가지고 있음 => 모든 HTTP 요청은 이 스레드 풀로 관리 함 </br>
- 톰켓의 스레드의 수는 동시에 들어오는 요청 지원 가능 상한선 ㅎ

</br>
더 많은 스레드 => 더 많은 리소스 => (클라우드 네이티브) 수평적 확장 </br>
</br>
"스프링 MVC" </br>
: 애플리케이션 구현 위한 (스프링 프레임워크에 포함된) 라이브러리 </br>
- 톰켓 같은 서버를 기반으로 함
- 그림 보면 스프링 애플리케이션이 REST 기반 요청/ 응답 상호작용 보여줌 

![image](https://github.com/user-attachments/assets/897ea862-5ea2-40a8-a995-baf5af415642)

</br>
DispatcherServlet(디스패처 서블렛) 이 REST 기반 요청/응답 을 처리하는 모양?</br>

- DispatcherServlet 은 요청 처리를 위한 진입점 역할을 수행
- HTTP 요청 받으면 DispatcherServlet은 HandlerMapping에게 컨트롤러 요청
- 컨트롤러가 실제 처리 (다른 서비스 호출해서)
- DispatcherServlet에 응답 반환 => 클라이언트에게 응답줌 

</br>
여기서 주목해야할 점은 톰캣 서버가 스프링 부트 애플리케이션에 어떻게 내장되어 있는 지 ! </br>
스프링 MVC는 => 웹 서버(톰켓)에 의존 함 : 자신의 기능 수행 위함임 </br>
우리는 웹 서버로 톰캣 사용중이나 톰캣에 대한 설정을 보자 ! </br>

</br>
</br>

## 3.2.3 내장 톰캣 설정 
톰캣은 ,.. </br>
기본 설정된 서버임 (그냥 포함) </br>
근데 사용자가 지정 변경해야할 수도 있잖아 ! </br>
</br>
톰켓은 application.properties, application.yml 둘 중 한개의 파일로 수정하는 데 우리는 yml 파일로 ! </br>


</br>

### 1. HTTP 포트 
- 기본적으로 내장 서버는 8080포트로 요청받음
- server.port 속성 통해 포트 지정 가능

### 2. 연결 타임아웃 
- 실제로 HTTP 요청을 받기 까지 톰캣이 최대한 기다리는 시간
- 서비스 거부 공격 DOS 방지
- 2s 정도가 적당

### 3. 스레드 풀 
- 톰캣은 요청당 스레드 모델에 따라 요청을 처리하는 스레드 풀 가지고 있다 했음
- threads.max 속성 : 최대 요청 처리 스레드 수 / threads.min-spare : 최소 스레드 수
- 기본 설정 값은 각각 200과 10

</br>
지금까지 클라우드 네이티브 애플리케이션은 내장 서버를 포함하는 JAR 파일로 패키징되어 

- 실행환경에 대한 추가적인 의존도 x
- 요청당 스레드 작동 원리 
- 톰캣, 스프링 MVC 요청 처리 흐름 및 톰켓 설정

</br>
다음 절 : 비즈니스 로직, REST API 구현 </br>
</br>


</br>

## 3.3 스프링 MVC를 이용한 RESTful 애플리케이션 구축 
클.네.애플리케이션을 구축하면 상호작용하는 여러 마이크로 서비스로 구성된 분산 시스템을 개발할 것임 </br>
: 그 때 서비스 간 통신에 필수적인 요소가 => API </br>
</br>
15요소 방법론 : API 우선 패턴 권장 => 서비스 인터페이스 먼저 결정 후 구현 작업은 나중에 ! </br>
</br>
이번 절 : 클.네.애플리케이션에서 가장 많이 사용하는 서비스 인터페이스 모델인 REST API로 카탈로그 서비스 계약을 정의할 것 </br>
</br>

### 3.3.1 REST API를 먼저, 비즈니스 로직은 그다음 
카탈로그 서비스는 도서에 대한 CRUD 작업을 수행 하기 위한 API를 제공해야함 </br>
비즈니스 로직을 살펴볼건데 세가지 개념 중심임 </br>
- 개체 : '책' 처럼, 한 도메인에서 명사 
- 서비스 : 도메인에 대한 사용 사례 정의 하고 구현 
- 리포지토리 : 데이터에 엑세스 하기 위한 추상화 계층 

</br>

### 도메인 개체 정의 
책은 "도메인 개체"임</br>
- domain 패키지 생성
- 개체 표현 위해 자바 레코드 Book 생성
<img width="428" alt="image" src="https://github.com/user-attachments/assets/f267040e-0329-49fa-9155-b7f226ae0253">

: 도메인 모델은 불가변 객체인 레코드로 구현됨 </br>
: 책을 고유하게 식별가능</br>
</br>

### 사용 사례 구현 
사용 사례는 @Service 클래스로 구현 가능 </br>
- BookService 클래스를 만들어보자. 
: 저자의 깃허브 코드를 복사 ! = https://github.com/ThomasVitale/cloud-native-spring-in-action

</br>

### 데이터 액세스를 위해 리포지터리 추상화 
BookRepository는 실제 구현에서 추상화를 분리해낸 인터페이스 - 도메인 계층에서 데이터 어떻게 저장되는 지 알필요 없기 때문 ! </br>
: BookRepository 인터페이스를 만들어보자 ! </br>
: 책 데이터에 액세스 하기 위한 추상화 정의 위한 인터페이스임 </br>

</br>
간단한 메모리 맵을 통해 책을 검색하고 저장하는 것만으로도 충분하기에 </br>
persistence 패키지에 InMemoryBookRepository 클래스를 만들어 BookRepository 인터페이스를 구현가능 </br>
</br>

### 4. 도메인 오류를 알리기 위한 예외의 사용 

- BookAlreadyExistException:
: 이미 존재하는 책 추가 시 오류
- BookNotFoundException :
: 카탈로그에 없는 책 가져오려고 할 시
</br>

이렇게 비즈니스 로직 완성, 비즈니스 로직은 다른 어떤 것과도 독립적이어야 함 . </br>
</br>

## 3.3.2 스프링 MVC를 이용한 REST API 구현 

이제 REST API를 통해 사용 사례를 외부로 노출할 수 있음 </br>
MVC는 @RestContoller 클래스 통해 특정 HTTP 메서드 및 리소스 엔드포인트에 HTTP 요청 처리 </br>

- 웹 계층위한 패키지 만들고 BookController 클래스 추가해 HTTP 요청 처리 하자  !

 </br>
 이제 애플리케이션을 실행해보고 HTTPie(커맨드라인 도구) 사용할 것 => http/ https를 터미널 창에서 사용가능 </br>
머야 ! 에러 처리 떄문에 실행 안되는데 ? </br>
... </br>

이제 에러처리 해줄거임 

</br>
</br>

### 3.3.3 데이터 유효성 검사 및 오류 처리 

일반적으로 데이터 저장 전, 데이터 일관성과 보안 위해 항상 유효성 검사 해야함 </br>
- 자바 빈 유효성 검사
: 제약조건 및 유효성 검사 위해 많이 사용하는 규격 </br>
: 스프링 부트는 API 및 스타터 의존성 제공 => build.gradle에 추가해보자.</br>

<img width="648" alt="image" src="https://github.com/user-attachments/assets/017ec702-c8b8-4316-8b67-2e326123c51e">

의존성을 추가했는데도 불구하고 validation이 제대로 임포트 되지 않음 </br>
=> 원인: </br>
스프링부트 2.3 부터 Validation Starter 가 Spring Boot Web과 분리가 되면서 동작을 하지 않는다. </br>
그래서 dependencies 를 추가로 작성해야 한다. </br>

- gradle 설정에 war 플러그인 추가
- dependencies 에 다음 코드 추가 : providedCompile 'jakarta.platform:jakarta.jakartaee-web-api:8.0.0'
</br>

이제 정상적으로 됨 </br>
스프링에게 Bookcontroller 클래스의 Book개체에 대한 유효성을 검사하도록 지시해야함 , </br>
어떻게 ? => @RequestBody가 메서드 인수로 지정될 때 @Valid 애너테이션을 사용하면 됨 </br>

</br>
이렇게 하면 ? => 책을 생성 및 업뎃 시 스프링은 유효성 검사_ 제약조건 위반시 오류 발생 </br>
: post() , put() 클래스 변경하자 </br>
</br>
- REST API 인 경우 HTTP응답은 목적에 맞는 상태 코드를 가져야 함_ 
- 클라이언트가 문제 발견하는데 도움이 되도록 의미있는 메시지 포함해야함 

REST API의 오류를 처리하려면 @RestControllerAdvice 클래스를 통해 어떤 작업 수행할 지 정의함 </br>
web 패키지에 BookControllerAdvice 클래스 새로 생성해보자 ! </br>
=> @RestControllerAdvice클래스는 예외와 상태코드 간 매핑을 제공함 </br>
</br>
머얌 .. domain 패키지 밑에 exception 에러 파일들을 추가해줌 .. 책에 없는데 </br>
<img width="385" alt="image" src="https://github.com/user-attachments/assets/a44955b7-98cd-4054-af55-f698b7636601">

</br>
빌드해서 애플리케이션을 실행시켜주고, 
<img width="853" alt="image" src="https://github.com/user-attachments/assets/75862c23-41e7-4cf2-9ab1-f7b3fad5afb9">
</br> 
머야 이건 </br>

### 3.3.4 미래 요구 사항을 위해 진화하는 API 
API 비저닝 
</br>

</br>

## 3.4 스프링 RESTful 애플리케이션 테스트 
자동화된 테스트 => 고품질 솦트웨어의 중요 요소 ! </br>
클라우드 네이티브 방식 채택의 목표 -> "속도", </br>
:지속적 전달 고사하고 자동화된 방식으로 코드 테스트 하지 않으면 속도는 불가능한 목표 </br>
</br>
자동화된 테스트 있다면 뭐가 좋아 ? </br>
: 코드 리팩터링 시 기존 작동 기능 손상 시킬 수 있기에 위험함, </br>
: 자동화된 테스트있다면 ? 두려움 없이 할 수 있음 </br>
</br>

- 테스트 커버리지 최대 => x
- 의미있는 테스트 작성 => o
: ex. 게터와 세터 메서드 테스트 코드 작성은 무의미</br>
</br>

</br>
테스트 주도 개발 TDD => 우리의 목표 달성에 도움 
