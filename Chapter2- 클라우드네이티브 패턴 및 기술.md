클라우드 네이티브 애플리케이션을 개발시,</br>
'12요소 방법론'에서 출발하면 좋음 (우수 사례와 개발 패턴으로 구성됨)=> 이번 장에서 알아볼 것 </br>
</br>
이번 장에서, </br>
코드가 클라우드 환경의 프로덕션까지 옮겨가는 과정을 그려보며, 사용할 패턴과 기술을 숙지해보자. </br>

<자바에서 컨테이너를 거쳐 쿠버네티스로 가는 스프링 애플리케이션의 여정></br>
![image](https://github.com/hansun-hub/CloudNativeSpringInAction/assets/68306239/4d761404-87fd-4f68-97d5-0c02e0c73443)  


애플리케이션 코드베이스를 빌드하면 자바 애플리케이션이 됨!  
자바 애플리케이션을 실행하면 자바 런타임됨!   
자바 애플리케이션을 패키징하면 컨테이너 이미지 됨    
컨테이너 이미지를 실행하면 컨테이너 런타임 됨  
...  

## 2.1 클라우드 네이티브 개발 원칙 : 12요소와 확장 
히로쿠 클라우드 플랫폼 엔지니어들은 자신의 경험을 정리해 모범사례로 제시했음 </br>
- 클라우드 플랫폼에 배포하기에 적합
- 확장을 염두에 둔 설계
- 다양한 시스템에 적용 가능
- 지속적 배포 및 민첩성 지원
12요소 방법론의 목표 : 최상의 결과 얻기 위해 고려할 중요 요소 강조하면서 클라우드 애플리케이션 구축 돕는 것</br>
=> 나중에 확장되어 : 15요소 방법론 </br>

## 2.1.1 하나의 코드베이스, 하나의 애플리케이션
15요소 방법론은 애플리케이션과 코드베이스 사이의 일대일 관계를 설정함 </br>


## 2.1.2 API 우선
클라우드 네이티브 애플리케이션을 설계시 API 우선 접근방식을 사용하면 => 좋다! </br>
API먼저 설계하면, 다른 팀은 해당 API를 가지고 자신들의 개발 진행 가능 => 다른 이유도 더 있긴 한데 암튼 좋다! </br>
</br>


## 2.1.3 의존성 관리
애플리케이션의 모든 의존 라이브러리는 명시적인 방식으로 선언되어야 함/ Maven, Gradle과 같은 도구 사용하면 이 원리 잘 따를 수 있음 </br>
</br>


## 2.1.4 설계, 빌드, 릴리스, 실행 
코드베이스는 설계부터 배포에 이르기까지 다양한 단계 거침</br>
- 설계단계 : 애플리케이션에 필요한 기술, 의존성 및 툴이 결정됨 
- 빌드단계 : 코드를 컴파일/의존 라이브러리와 함께 패키지로 만들어 빌드(불가변 아티팩트:고유하게 식별가능)생성 
- 릴리스단계 : 배포위해 빌드를 특정 설정과 결합함_ 각 릴리스는 변경x, 버전 관리 방식에 따라 시맨틱 버저닝, 타임스탬프 사용해 고유하게 식별가능해야함, 중앙 저장소에 저장되어야함 (롤백시 이전 버전으로 돌아가기 위해)
- 실행단계 : 특정 릴리스가 실행환경에서 동작함

이런 단계가 엄격하게 분리되어야 함 </br>
빌드 및 릴리스 아티팩트는 변경할 수 없고 재생성 위해 고유한 식별자로 지정해야 함 </br>

## 2.1.5 설정, 크리덴셜 코드 
15요소 방법론에서의 설정의 정의: 배포 사이에 변경될 가능성이 있는 모든 것 </br>
설정을 변경해야 한다면 코드의 변경/재빌드 없이도 할 수 있어야함 </br>
</br>
15요소 방법론은 환경 변수를 사용한 설정 권고 - 다른 환경에 배포할 수 있지만 환경에 따라 다르게 작동하도록 배포가능</br>
</br>

## 2.1.6 로그 
로그 저장에 애플리케이션이 신경쓰지 말아야 함 </br>
로그 수집기와 같은 외부 툴 사용해 수집하고 검사 가능</br>

## 2.1.7 일회성
언제라도 애플리케이션을 시작 및 중지할 수 있는 경우 => 이 애플리케이션은 일회성이다. </br>
우아한 종료 : 종료 신호를 받으면 새로운 요청 수락 x 진행중인 요청 모두 완료 후 종료하는 것 </br>
</br>

## 2.1.8 지원 서비스 backing service
애플리케이션이 자신의 기능을 제공하기 위해 사용하는 외부 리소스 : 지원 서비스 </br>
ex: 데이터베이스, SMTP서버 ....</br>
이들을 탈착식 리소스처럼 처리하면 코드 수정 없이도 리소스 쉽게 변경 가능 </br>
</br>

## 2.1.9 환경 동일성 
모든 환경을 가능한 한 비슷하게 유지하는 것 : 환경 동일성</br>
메꾸고자 하는 간극은 세 가지 : </br>
- 시간차이: 코드를 작성한 이후부터 배포할때 까지의 기간 
- 사람차이
- 도구차이

</br>

## 2.1.0 관리 프로세스 
일반적으로 관리 작업은 </br>
- 독립형 서비스 : 한 번 실행 후 더이상 사용하지 않는 작은 독립형 서비스
- 특정 이벤트 발생시 실행하도록 설정한 함수
- 애플리케이션의 일부로 특정 엔드포인트 호출해 실행
이렇게 하는 것이 좋다! </br>

</br>

## 2.1.11 포트 바인딩 
15요소 방법론 따르는 애플리케이션은 </br>
- 독립적이어야함 
- 포트 바인딩 통해 서비스 제공해야 함(엔드포인트로 들어온 요청을 특정 내부 서비스로 변환하는 라우팅 서비스 가능함)
</br>
독립적이다 = 애플리케이션이 실행 환경에서 외부 서버에 의존하지 않는 경우 </br>
- 자바 웹 애플리케이션 : 톰캣 같은 서버 컨테이너에서 실행할 수 있음 (독립적 x)
반면, 클라우드 네이티브 애플리케이션은 .. </br>
실행환경이 톰캣 같은 서버 컨테이너를 제공하도록 규정하는 대신 '자체적으로 의존성 관리함' </br>
</br>
ex. 스프링 부트 사용 시 서버가 임베디드 형태로 제공되거든 => 즉 </br>
애플리케이션은 실행환경이 제공하는 서버에 의존하는 대신, 자신의 내부에 웹 애플리케이션 서버를 가지고 있음</br>
=> 이러한 접근법은 웹 애플리케이션 서버 하나에 애플리케이션이 하나만 존재함 </br>
</br>

## 2.1.12 상태를 갖지 않는 프로세스 
'확장성'을 가지기 위해서는 ?</br>
- 상태를 갖지 않아야 함(프로스세스가)
- 아무것도 공유하지 않아야함(아키텍처가)

상태를 가지고 있다? </br>
- 애플리케이션 인스턴스 파괴 후 새로 만들면 데이터 손실된다면 , YES

근데, " 무엇이 되었든 상태는 저장해야 한다. " => 그렇지 않으면 쓸모 없어짐 </br>
그러면 어떻게 하라고? 확장성 위해서는 상태를 갖지 말라면서 상태를 저장안하면 쓸모가 없다니... </br></br>
=> 상태를 갖지 않도록 설계하고 대신 ! 상태는 데이터 저장소 같은 서비스 통해 처리해라 </br>
: 정리 ㅣ 상태를 갖지 않는 애플리케이션은 상태의 관리 및 저장을 지원 서비스에 위임하게 됨 </br>

</br>

## 2.1.13 동시성 
상태 갖지 않도록 하는 것 만으로는 => 확장성 담보 부족 </br>
확장성이라는 건 더 많은 사용자에게 서비스 제공 말하는 거잖아 => "동시성" 통해 더 많은 사용자에게 서비스 제공하면 되겠네 !</br>
</br>
15요소 방법론에서는 프로세스를 제약없이 다룰 수 있어야함 => 이렇게 함으로서 동시성을 확보 가능 </br>
: 여러 머신에 여러 개의 프로세스에 워크로드를 분산함으로서 : 수평적으로 확장(프로세스를) 할 수 있어야 하는데 ! </br>
=> 애플리케이션이 상태를 갖지 않을 때만 동시 처리가 가능해짐 (그래서 앞에서 언급한건가봐)</br>
</br>
우리가 잘 아는 JVM 애플리케이션에서의 동시성 처리 : 스레드 풀 내의 사용 가능한 스레드 사용해서 </br>
</br>
프로세스를 제약없이 다룰 수 있어야 한다고 했지 ? "프로세스는" 종류에 따라 분류가 가능함 </br>
- 웹 프로세스 : HTTP 요청을 처리하는
- 작업자 프로세스 : 백그라운드에서 예약된 작업을 실행하는


</br>

## 2.1.14 원격 측정 
원격 측정 데이터의 예로는 로그, 메트릭, 추적, 상태, 이벤트가 있음 </br>

## 2.1.15 인증 및 승인 
보안 .. 중요하지 .. 훗</br>
우선 제로 트러스트 접근법에 따라 시스템 내 상호작용의 안전성은 </br>
모든 설계적, 인프라적 수준에서 확보되어야 함 _ 보안 관련 다른 많은 것들이 있지만 여기서부터 출발하자. </br>
</br>
인증 => 누가 애플리케이션 사용하고 있는 지 추적가능</br>
권한 => 특정 작업 수행할 수 있는 지 확인 가능</br>
ID 및 액세스 관리 구현 위한 표준 몇가지 존재 - 이 책에서는 OAuth 2.0 및 오픈ID 커넥트(OIDC)를 사용함</br>

## 2.2 스프링을 사용한 클라우드 네이티브 애플리케이션 구축 
지금까지 접근 방식과 주요 개발 관행에 대해 살펴봄, 이제 기술적인 부분에 대해 논의위해 스프링을 살펴보자. </br>
이번 절에서는 스프링의 흥미로운 몇 가지 특징을 살펴보고자 함 </br>

## 2.2.1 스프링 개요 
스프링은... </br>
- 여러 프로젝트로 이루어져 있다. (웹 애플리케이션, 보안, 데이터 엑세스, 통합, 배치 처리 등 개발의 다양한 측면을 다루는)
- 모듈식 설계로 필요한 프로젝트만 사용하고 이들을 결합할 수 있음 </br>
</br>
스프링 플랫폼은 이 모든 것을 시작한 프로젝트 ! </br>
핵심은 스프링 프레임워크 Spring Framework .</br>
=> 의존성 주입, 트랜잭션 관리, 데이터 액세스 등을 지원함 .. 이들을 그냥 엮기만 해도 기업 애플리케이션 구축가능 .</br>
</br>
스프링 프레임워크는.. <br>
스프링 콘텍스트Spring Context 또는 스프링 컨테이너 Spring Container 라고 부르는 "실행 콘텍스트" 제공</br>
여기에서 빈, 속성, 리소스가 애플리케이션의 전체 라이프 사이클에 걸쳐 관리됨 ... </br>
=> 스프링 콘텍스트의 역할을 인식하고 스프링 빈, 애너테이션 기반 설정, 의존성 주입 기능을 잘 활용해야함^0^  </br>
</br>

## 2.2.2 스프링 부트 애플리케이션 구축 
<가정을 해보자 ! ✍️> </br>
프로젝트를 참여하게 되었다 ! <폴라 복숍 애플리케이션 구축 프로젝트 > </br>
- 전문 서점 관리 및 책을 온라인으로 판매함
: 클라우드 네이티브 방식 고려중 </br>
</br>
이 프로젝트를 구현한 후에는 클라우드에 배포되는 것 까지 과정이 어떻게 이루어지는지를 동료들에게 보여줘야 함 </br>
- 웹 애플리케이션 : 카탈로그 서비스
- 목표 : 사용자 환영 문구 보여주기
</br>
그렇다면 .. </br>
: 환영 메시지 반환하는 HTTP 엔드포인트 하나 갖는 RESTful 서비스 구현 하기 ! </br>
: 서비스의 기본 기술 스택은 스프링 ! </br>
: 시스템의 아키텍처

![image](https://github.com/hansun-hub/CloudNativeSpringInAction/assets/68306239/0ecf8dd8-1b9e-4eca-91cc-296071e014be)

</br>
C4모델을 따라 만든 아키텍처 다이어그램임 </br>
세 가지 추상화 : </br>
- 사람 : 시스템을 사용하는 사람 => 서점의 고객
- 시스템 : 가치 제공하는 애플리케이션 => 폴라 북숍 시스템 
- 컨테이너 : => 카탈로그 서비스 

</br>
이 업무를 위해서 스프링 프레임워크와 스프링 부트를 사용해 다음 작업 수행할 것 </br>
- 의존성 선언
- 스프링 부트로 애플리케이션을 부트스트래핑
- HTTP 엔드포인트를 통해 환영 메시지 반환하는 컨트롤러 구현
</br>

### 1. 프로젝트 초기화 
1. catalog-service 라는 이름으로 깃 저장소 생성
2. 스프링 이니셜라이저에서 스프링 부트 프로젝트 하나 생성하고 catalog-service 저장소에 저장
스프링 이니셜라이저...?</br>
   : 브라우저 또는 REST API 통해 JVM 기반 프로젝트 생성휘해 사용하는 편리한 서비스 </br>

























