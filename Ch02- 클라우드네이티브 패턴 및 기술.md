클라우드 네이티브 애플리케이션을 개발시,</br>
'12요소 방법론'에서 출발하면 좋음 (우수 사례와 개발 패턴으로 구성됨)=> 이번 장에서 알아볼 것 </br>
</br>
이번 장에서, </br>
코드가 클라우드 환경의 프로덕션까지 옮겨가는 과정을 그려보며, 사용할 패턴과 기술을 숙지해보자. </br>

<자바에서 컨테이너를 거쳐 쿠버네티스로 가는 스프링 애플리케이션의 여정></br>
![image](https://github.com/hansun-hub/CloudNativeSpringInAction/assets/68306239/4d761404-87fd-4f68-97d5-0c02e0c73443)  


애플리케이션 코드베이스를 빌드하면 자바 애플리케이션이 됨!  
자바 애플리케이션을 실행하면 자바 런타임됨!   
자바 애플리케이션을 패키징하면 컨테이너 이미지 됨    
컨테이너 이미지를 실행하면 컨테이너 런타임 됨  
...  

## 2.1 클라우드 네이티브 개발 원칙 : 12요소와 확장 
히로쿠 클라우드 플랫폼 엔지니어들은 자신의 경험을 정리해 모범사례로 제시했음 </br>
- 클라우드 플랫폼에 배포하기에 적합
- 확장을 염두에 둔 설계
- 다양한 시스템에 적용 가능
- 지속적 배포 및 민첩성 지원
12요소 방법론의 목표 : 최상의 결과 얻기 위해 고려할 중요 요소 강조하면서 클라우드 애플리케이션 구축 돕는 것</br>
=> 나중에 확장되어 : 15요소 방법론 </br>

## 2.1.1 하나의 코드베이스, 하나의 애플리케이션
15요소 방법론은 애플리케이션과 코드베이스 사이의 일대일 관계를 설정함 </br>


## 2.1.2 API 우선
클라우드 네이티브 애플리케이션을 설계시 API 우선 접근방식을 사용하면 => 좋다! </br>
API먼저 설계하면, 다른 팀은 해당 API를 가지고 자신들의 개발 진행 가능 => 다른 이유도 더 있긴 한데 암튼 좋다! </br>
</br>


## 2.1.3 의존성 관리
애플리케이션의 모든 의존 라이브러리는 명시적인 방식으로 선언되어야 함/ Maven, Gradle과 같은 도구 사용하면 이 원리 잘 따를 수 있음 </br>
</br>


## 2.1.4 설계, 빌드, 릴리스, 실행 
코드베이스는 설계부터 배포에 이르기까지 다양한 단계 거침</br>
- 설계단계 : 애플리케이션에 필요한 기술, 의존성 및 툴이 결정됨 
- 빌드단계 : 코드를 컴파일/의존 라이브러리와 함께 패키지로 만들어 빌드(불가변 아티팩트:고유하게 식별가능)생성 
- 릴리스단계 : 배포위해 빌드를 특정 설정과 결합함_ 각 릴리스는 변경x, 버전 관리 방식에 따라 시맨틱 버저닝, 타임스탬프 사용해 고유하게 식별가능해야함, 중앙 저장소에 저장되어야함 (롤백시 이전 버전으로 돌아가기 위해)
- 실행단계 : 특정 릴리스가 실행환경에서 동작함

이런 단계가 엄격하게 분리되어야 함 </br>
빌드 및 릴리스 아티팩트는 변경할 수 없고 재생성 위해 고유한 식별자로 지정해야 함 </br>

## 2.1.5 설정, 크리덴셜 코드 
15요소 방법론에서의 설정의 정의: 배포 사이에 변경될 가능성이 있는 모든 것 </br>
설정을 변경해야 한다면 코드의 변경/재빌드 없이도 할 수 있어야함 </br>
</br>
15요소 방법론은 환경 변수를 사용한 설정 권고 - 다른 환경에 배포할 수 있지만 환경에 따라 다르게 작동하도록 배포가능</br>
</br>

## 2.1.6 로그 
로그 저장에 애플리케이션이 신경쓰지 말아야 함 </br>
로그 수집기와 같은 외부 툴 사용해 수집하고 검사 가능</br>

## 2.1.7 일회성
언제라도 애플리케이션을 시작 및 중지할 수 있는 경우 => 이 애플리케이션은 일회성이다. </br>
우아한 종료 : 종료 신호를 받으면 새로운 요청 수락 x 진행중인 요청 모두 완료 후 종료하는 것 </br>
</br>

## 2.1.8 지원 서비스 backing service
애플리케이션이 자신의 기능을 제공하기 위해 사용하는 외부 리소스 : 지원 서비스 </br>
ex: 데이터베이스, SMTP서버 ....</br>
이들을 탈착식 리소스처럼 처리하면 코드 수정 없이도 리소스 쉽게 변경 가능 </br>
</br>

## 2.1.9 환경 동일성 
모든 환경을 가능한 한 비슷하게 유지하는 것 : 환경 동일성</br>
메꾸고자 하는 간극은 세 가지 : </br>
- 시간차이: 코드를 작성한 이후부터 배포할때 까지의 기간 
- 사람차이
- 도구차이

</br>

## 2.1.0 관리 프로세스 
일반적으로 관리 작업은 </br>
- 독립형 서비스 : 한 번 실행 후 더이상 사용하지 않는 작은 독립형 서비스
- 특정 이벤트 발생시 실행하도록 설정한 함수
- 애플리케이션의 일부로 특정 엔드포인트 호출해 실행
이렇게 하는 것이 좋다! </br>

</br>

## 2.1.11 포트 바인딩 
15요소 방법론 따르는 애플리케이션은 </br>
- 독립적이어야함 
- 포트 바인딩 통해 서비스 제공해야 함(엔드포인트로 들어온 요청을 특정 내부 서비스로 변환하는 라우팅 서비스 가능함)
</br>
독립적이다 = 애플리케이션이 실행 환경에서 외부 서버에 의존하지 않는 경우 </br>
- 자바 웹 애플리케이션 : 톰캣 같은 서버 컨테이너에서 실행할 수 있음 (독립적 x)
반면, 클라우드 네이티브 애플리케이션은 .. </br>
실행환경이 톰캣 같은 서버 컨테이너를 제공하도록 규정하는 대신 '자체적으로 의존성 관리함' </br>
</br>
ex. 스프링 부트 사용 시 서버가 임베디드 형태로 제공되거든 => 즉 </br>
애플리케이션은 실행환경이 제공하는 서버에 의존하는 대신, 자신의 내부에 웹 애플리케이션 서버를 가지고 있음</br>
=> 이러한 접근법은 웹 애플리케이션 서버 하나에 애플리케이션이 하나만 존재함 </br>
</br>

## 2.1.12 상태를 갖지 않는 프로세스 
'확장성'을 가지기 위해서는 ?</br>
- 상태를 갖지 않아야 함(프로스세스가)
- 아무것도 공유하지 않아야함(아키텍처가)

상태를 가지고 있다? </br>
- 애플리케이션 인스턴스 파괴 후 새로 만들면 데이터 손실된다면 , YES

근데, " 무엇이 되었든 상태는 저장해야 한다. " => 그렇지 않으면 쓸모 없어짐 </br>
그러면 어떻게 하라고? 확장성 위해서는 상태를 갖지 말라면서 상태를 저장안하면 쓸모가 없다니... </br></br>
=> 상태를 갖지 않도록 설계하고 대신 ! 상태는 데이터 저장소 같은 서비스 통해 처리해라 </br>
: 정리 ㅣ 상태를 갖지 않는 애플리케이션은 상태의 관리 및 저장을 지원 서비스에 위임하게 됨 </br>

</br>

## 2.1.13 동시성 
상태 갖지 않도록 하는 것 만으로는 => 확장성 담보 부족 </br>
확장성이라는 건 더 많은 사용자에게 서비스 제공 말하는 거잖아 => "동시성" 통해 더 많은 사용자에게 서비스 제공하면 되겠네 !</br>
</br>
15요소 방법론에서는 프로세스를 제약없이 다룰 수 있어야함 => 이렇게 함으로서 동시성을 확보 가능 </br>
: 여러 머신에 여러 개의 프로세스에 워크로드를 분산함으로서 : 수평적으로 확장(프로세스를) 할 수 있어야 하는데 ! </br>
=> 애플리케이션이 상태를 갖지 않을 때만 동시 처리가 가능해짐 (그래서 앞에서 언급한건가봐)</br>
</br>
우리가 잘 아는 JVM 애플리케이션에서의 동시성 처리 : 스레드 풀 내의 사용 가능한 스레드 사용해서 </br>
</br>
프로세스를 제약없이 다룰 수 있어야 한다고 했지 ? "프로세스는" 종류에 따라 분류가 가능함 </br>
- 웹 프로세스 : HTTP 요청을 처리하는
- 작업자 프로세스 : 백그라운드에서 예약된 작업을 실행하는


</br>

## 2.1.14 원격 측정 
원격 측정 데이터의 예로는 로그, 메트릭, 추적, 상태, 이벤트가 있음 </br>

## 2.1.15 인증 및 승인 
보안 .. 중요하지 .. 훗</br>
우선 제로 트러스트 접근법에 따라 시스템 내 상호작용의 안전성은 </br>
모든 설계적, 인프라적 수준에서 확보되어야 함 _ 보안 관련 다른 많은 것들이 있지만 여기서부터 출발하자. </br>
</br>
인증 => 누가 애플리케이션 사용하고 있는 지 추적가능</br>
권한 => 특정 작업 수행할 수 있는 지 확인 가능</br>
ID 및 액세스 관리 구현 위한 표준 몇가지 존재 - 이 책에서는 OAuth 2.0 및 오픈ID 커넥트(OIDC)를 사용함</br>

## 2.2 스프링을 사용한 클라우드 네이티브 애플리케이션 구축 
지금까지 접근 방식과 주요 개발 관행에 대해 살펴봄, 이제 기술적인 부분에 대해 논의위해 스프링을 살펴보자. </br>
이번 절에서는 스프링의 흥미로운 몇 가지 특징을 살펴보고자 함 </br>

## 2.2.1 스프링 개요 
스프링은... </br>
- 여러 프로젝트로 이루어져 있다. (웹 애플리케이션, 보안, 데이터 엑세스, 통합, 배치 처리 등 개발의 다양한 측면을 다루는)
- 모듈식 설계로 필요한 프로젝트만 사용하고 이들을 결합할 수 있음 </br>
</br>
스프링 플랫폼은 이 모든 것을 시작한 프로젝트 ! </br>
핵심은 스프링 프레임워크 Spring Framework .</br>
=> 의존성 주입, 트랜잭션 관리, 데이터 액세스 등을 지원함 .. 이들을 그냥 엮기만 해도 기업 애플리케이션 구축가능 .</br>
</br>
스프링 프레임워크는.. <br>
스프링 콘텍스트Spring Context 또는 스프링 컨테이너 Spring Container 라고 부르는 "실행 콘텍스트" 제공</br>
여기에서 빈, 속성, 리소스가 애플리케이션의 전체 라이프 사이클에 걸쳐 관리됨 ... </br>
=> 스프링 콘텍스트의 역할을 인식하고 스프링 빈, 애너테이션 기반 설정, 의존성 주입 기능을 잘 활용해야함^0^  </br>
</br>

## 2.2.2 스프링 부트 애플리케이션 구축 
<가정을 해보자 ! ✍️> </br>
프로젝트를 참여하게 되었다 ! <폴라 복숍 애플리케이션 구축 프로젝트 > </br>
- 전문 서점 관리 및 책을 온라인으로 판매함
: 클라우드 네이티브 방식 고려중 </br>
</br>
이 프로젝트를 구현한 후에는 클라우드에 배포되는 것 까지 과정이 어떻게 이루어지는지를 동료들에게 보여줘야 함 </br>
- 웹 애플리케이션 : 카탈로그 서비스
- 목표 : 사용자 환영 문구 보여주기
</br>
그렇다면 .. </br>
: 환영 메시지 반환하는 HTTP 엔드포인트 하나 갖는 RESTful 서비스 구현 하기 ! </br>
: 서비스의 기본 기술 스택은 스프링 ! </br>
: 시스템의 아키텍처

![image](https://github.com/hansun-hub/CloudNativeSpringInAction/assets/68306239/0ecf8dd8-1b9e-4eca-91cc-296071e014be)

</br>
C4모델을 따라 만든 아키텍처 다이어그램임 </br>
세 가지 추상화 : </br>

- 사람 : 시스템을 사용하는 사람 => 서점의 고객
- 시스템 : 가치 제공하는 애플리케이션 => 폴라 북숍 시스템 
- 컨테이너 : => 카탈로그 서비스 

</br>
이 업무를 위해서 스프링 프레임워크와 스프링 부트를 사용해 다음 작업 수행할 것 </br>

- 의존성 선언
- 스프링 부트로 애플리케이션을 부트스트래핑
- HTTP 엔드포인트를 통해 환영 메시지 반환하는 컨트롤러 구현
</br>

### 1. 프로젝트 초기화 
1. catalog-service 라는 이름으로 깃 저장소 생성
2. 스프링 이니셜라이저에서 스프링 부트 프로젝트 하나 생성하고 catalog-service 저장소에 저장
스프링 이니셜라이저...?</br>
   : 브라우저 또는 REST API 통해 JVM 기반 프로젝트 생성휘해 사용하는 편리한 서비스 </br>

<img width="1274" alt="image" src="https://github.com/hansun-hub/CloudNativeSpringInAction/assets/68306239/19e7f035-4f6f-4e79-950e-42af8f46d65b">


### 2. 빌드 설정
이 프로젝트가 포함하는 주요 의존성 라이브러리는 다음과 같음</br>
- 스프링 웹: 스프링 MVC로 웹 애플리케이션 빌드 시 필요한 라이브러리 제공/ 임베디드 서버로는 톰캣 포함
- 스프링 부트 테스트 : 테스트 할 수 있는 여러 라이브러리 및 유틸리티 제공


</br>

### 3. 애플리케이션 부트스트래핑 
앞서 spring initializer 에서 JAR 패키징 옵션 선택함 </br>
JAR 로 패키징되어있다? => 실행할 public static void main(String[] args) 메서드를 시작할 때</br>
가지고 있어야 함 => 스프링 부트도 마찬가지  ! </br>
</br>
이 카탈로그 서비스에서는 자동 생성된 CatalogServiceApplication이라는 클래스 안에</br>
main() 메서드를 정의해 애플리케이션 실행함 </br>
</br>


public static void main(String[] args) 메서드 :</br>
애플리케이션을 시작하는 메서드</br>

</br>

@SpringBootApplication :</br>
스프링 설정 클래스를 정의하고 컴포넌트 스캔과 스프링 부트 자동 설정을 실행함
세 가지 다른 애너테이션을 한꺼번에 포함</br>
- @Configuration : 해당 클래스가 빈을 정의하는 클래스임을 나타냄
- @ComponentScan : 컴포넌트 검색을 통해 빈을 찾아 스프링 콘텍스트에 자동으로 등록함
- @EnableAutoConfiguration : 스프링 부트에서 제공하는 자동 설정 기능을 활성화함
</br>
우리 프로젝트의 경우 자동설정 기능 뭐있냐?... </br>
=> Spring-boot-starter-web에 의존 => </br>
스프링 부트는 임베티드 톰캣 서버 인스턴스를 초기화, 애플리케이션 실행 위한 최소한의 설정 적용해 실행함 </br>
</br>
지금까지 설정에 대해 살펴봄 .. 카탈로그 서비스에서 HTTP 엔드폰인트를 외부로 노출해볼 것 . </br>
</br>



### 4. 컨트롤러 구현 
이제 비즈니스 로직을 구현할 때임 </br>
: 카탈로그 서비스는 인사말을 반환하는 HTTP GET 엔드포인트를 노출함 </br>
: 컨트롤러 클래스에서 이에 대한 핸들러를 정의 가능

</br>
- 프로젝트에서 HomeController 클래스 생성 하고 루트 엔드포인트로 GET 요청 처리 메서드 구현할 것 
- @RestController : REST/HTTP 엔드포인트를 위한 핸들러를 정의하는 클래스로 인식 
- @GetMapping("/") : 루트 엔드포인트로 GET 요청을 처리 

</br>

### 5. 애플리케이션 테스트 
build.gradle 파일은 스프링 애플리케이션을 테스트하는 데 필요한 의존성 라이브러리를 자동으로 가져옴 </br>

![image](https://github.com/hansun-hub/CloudNativeSpringInAction/assets/68306239/494eb751-48b6-4f4b-87c8-45d4c70308ab)


</br>
@SpringBootTest : </br>
테스트를 실행할 전체 스프링 애플리케이션 콘텍스트를 로드함 </br>
지금 코드를 보면, 테스트 케이스 하나에, 그마저도 비어있지만 => 스프링 콘텍스트가 올바르게 로드되었는지 확인하는데 사용할것</br>
</br>

터미널 - command Prompt 창 키기  -애플리케이션 루트 폴더 (catalog-service)로 이동 - 에러 발생 </br>
! 참고 블로그❗️<br>
https://velog.io/@kcho32/Execution-failed-for-task-compileJava.-invalid-source-release-11
</br>
https://yungenie.tistory.com/11
</br>
: java17이 설치되어 있지 않았던 것 같다.-> 설치되어있었는데 위치가 이상해서 환경변수를 변경해주었다. 
</br>

./gradlew test 입력 => BUILD SUCCESSFUL (녹색)
</br>

## 6. 애플리케이션 실행 
구현 끝났으니 실행할 수 잇음 </br>
- ./gradlew bootRun 입력 : 애플리케이션 실행됨
  </br>
애플리케이션 시작은 두 가지 단계.. </br> 
- 내장된 톰캣 서버의 초기화 및 실행
- 스프링 애플리케이션 콘텍스트의 초기화 및 실행

</br>
이제 브라우저 창을 열고 http://localhost:8080/ 방문하면 환영한다는 응답확인가능 </br>

![image](https://github.com/hansun-hub/CloudNativeSpringInAction/assets/68306239/bbab5609-cdc3-46af-8802-869264cf7321)

다음 단계는 애플리케이션을 클라우드에 배포하는 것 </br>
어떤 클라우드 인프라로도 배포할 수 있으려면 먼저 컨테이너화해야함 ! </br>
</br>

## 2.3 도커를 통한 애플리케이션 컨테이너화 
클라우드에 배포하려면.. </br>
애플리케이션을 컨테이너로 만들어야함. 왜?</br>
- 주변환경과의 격리 가능
- 실행할 때 필요한 모든 것이 컨테이너 안에 준비됨

그와 비교하여 우리는 대부분의 의존성이...</br>
- 그래들에 의해 관리됨
- 애플리케이션과 함께 JAR 아티팩트로 패키징됨 .. 그러나 자바 런타임은 이 아티팩트에 포함되지 않음
즉, 컨테이너를 사용하지 않는다면 </br>
=> 애플리케이션을 배포하는 머신에 자바 런타임 설치 필요</br>

암튼 컨테이너 사용하면 언어나 프레임워크 상관없이 표준적인 방식으로 애플리케이션 관리 가능하고 독립적이고 이식가능해진다.</br>
</br>
</hr>
</br>
OCI란...?</br>
: 컨테이너 작업을 위한 업계표준을 정의하는 프로젝트._ 우리가 컨테이너 작업에 사용할 도구는 OCI 사양을 준수하는 도커임. </br>
</br>
도커란...?<br>
: 컨테이너라는 느슨하게 격리된 환경에서 애플리케이션을 패키징하고 실행할 수 있는 기능을 제공하는 오픈소스 플랫폼 . </br>

</br>

## 2.3.1 도커 소개: 이미지 및 컨테이너 
1. 도커 서버
: 도커 데몬이 포함 => 백그라운드에서 실행하면서 이미지, 컨테이너 같은 도커 객체를 만들고 관리함</br>
: 도커 서버가 실행되는 컴퓨터를 => 도커 호스트 (컨테이너 실행하려면 도커 호스트여야하고 데몬 실행중이어야함)</br>
: 도커 데몬은 API를 제공 => 이 API 통해서 컨테이너 실행같은 명령을 도커에 전달 가능 </br>


3. 도커 클라이언트

4. 컨테이너 저장소 

























